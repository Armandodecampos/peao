<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dado do Mentiroso - Supabase</title>
    <!-- Carrega o Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Carrega as fontes do Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&family=Cinzel+Decorative:wght@700&display=swap" rel="stylesheet">
    <!-- Carrega o cliente Supabase -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        /* Estilo para o spinner de carregamento */
        .loader {
            border-top-color: #e5a938; /* Cor de ouro para o spinner */
            -webkit-animation: spin 1s linear infinite;
            animation: spin 1s linear infinite;
        }
        @-webkit-keyframes spin {
            0% { -webkit-transform: rotate(0deg); }
            100% { -webkit-transform: rotate(360deg); }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Animação de rotação dos dados */
        @keyframes dice-roll {
            0% {
                transform: rotate(0deg) scale(1);
            }
            50% {
                transform: rotate(180deg) scale(1.2);
            }
            100% {
                transform: rotate(360deg) scale(1);
            }
        }
        .dice-roll-animation {
            animation: dice-roll 0.5s ease-out;
        }
        /* Animação de explosão para o dado perdido */
        @keyframes dice-explode {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.5) rotate(180deg);
                opacity: 0.5;
            }
            100% {
                transform: scale(0) rotate(360deg);
                opacity: 0;
            }
        }
        .dice-explode-animation {
            /* 'forwards' mantém o estado final da animação (invisível) */
            animation: dice-explode 0.6s ease-in-out forwards;
        }
        body {
            font-family: 'Merriweather', serif;
        }
        .font-title {
            font-family: 'Cinzel Decorative', cursive;
        }
        /* Personalização da barra de rolagem para um visual mais rústico */
        #history-container::-webkit-scrollbar {
            width: 8px;
        }
        #history-container::-webkit-scrollbar-track {
            background: #4a2c2a; /* Marrom escuro para a trilha */
        }
        #history-container::-webkit-scrollbar-thumb {
            background: #e5a938; /* Dourado para o polegar */
            border-radius: 4px;
            border: 1px solid #4a2c2a;
        }

        /* Novas animações para o anúncio de ação */
        @keyframes slide-in-from-left {
            from { transform: translateX(-100vw); }
            to { transform: translateX(0); }
        }
        .animate-slide-in-from-left {
            animation: slide-in-from-left 0.5s cubic-bezier(0.250, 0.460, 0.450, 0.940) both;
        }
        @keyframes fade-out {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        .animate-fade-out {
            animation: fade-out 0.5s ease-out both;
        }

        /* Novas animações para o Vencedor Final */
        @keyframes winner-intro {
            0% {
                transform: scale(0.5) translateY(-100px);
                opacity: 0;
            }
            60% {
                transform: scale(1.1);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        .animate-winner-intro {
            animation: winner-intro 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) both;
        }
    </style>
</head>
<body id="page-body" class="bg-[#3d2323] text-[#f3e9d2] flex flex-col md:items-center md:justify-center min-h-screen">

    <!-- SVG Definitions for Dice -->
    <svg width="0" height="0" style="position:absolute">
        <defs>
            <symbol id="dice-1" viewBox="0 0 100 100">
                <rect width="100" height="100" rx="15" fill="white" stroke="black" stroke-width="2"/>
                <circle cx="50" cy="50" r="10" fill="black"/>
            </symbol>
            <symbol id="dice-2" viewBox="0 0 100 100">
                <rect width="100" height="100" rx="15" fill="white" stroke="black" stroke-width="2"/>
                <circle cx="25" cy="25" r="10" fill="black"/>
                <circle cx="75" cy="75" r="10" fill="black"/>
            </symbol>
            <symbol id="dice-3" viewBox="0 0 100 100">
                <rect width="100" height="100" rx="15" fill="white" stroke="black" stroke-width="2"/>
                <circle cx="25" cy="25" r="10" fill="black"/>
                <circle cx="50" cy="50" r="10" fill="black"/>
                <circle cx="75" cy="75" r="10" fill="black"/>
            </symbol>
            <symbol id="dice-4" viewBox="0 0 100 100">
                <rect width="100" height="100" rx="15" fill="white" stroke="black" stroke-width="2"/>
                <circle cx="25" cy="25" r="10" fill="black"/>
                <circle cx="75" cy="25" r="10" fill="black"/>
                <circle cx="25" cy="75" r="10" fill="black"/>
                <circle cx="75" cy="75" r="10" fill="black"/>
            </symbol>
            <symbol id="dice-5" viewBox="0 0 100 100">
                <rect width="100" height="100" rx="15" fill="white" stroke="black" stroke-width="2"/>
                <circle cx="25" cy="25" r="10" fill="black"/>
                <circle cx="75" cy="25" r="10" fill="black"/>
                <circle cx="50" cy="50" r="10" fill="black"/>
                <circle cx="25" cy="75" r="10" fill="black"/>
                <circle cx="75" cy="75" r="10" fill="black"/>
            </symbol>
            <symbol id="dice-6" viewBox="0 0 100 100">
                <rect width="100" height="100" rx="15" fill="white" stroke="black" stroke-width="2"/>
                <circle cx="25" cy="25" r="10" fill="black"/>
                <circle cx="75" cy="25" r="10" fill="black"/>
                <circle cx="25" cy="50" r="10" fill="black"/>
                <circle cx="75" cy="50" r="10" fill="black"/>
                <circle cx="25" cy="75" r="10" fill="black"/>
                <circle cx="75" cy="75" r="10" fill="black"/>
            </symbol>
        </defs>
    </svg>

    <!-- Botões de Controle (Música e Perfil) - Visíveis no Lobby -->
    <div id="top-right-controls" class="hidden fixed top-4 right-4 z-50 flex gap-2">
        <button id="music-toggle-btn" class="text-[#e5a938] bg-[#4a2c2a] p-2 rounded-full shadow-lg hover:bg-[#5a3c3a] transition-colors duration-200">
            <!-- Icone de som on -->
            <svg id="music-on-icon" xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
            </svg>
            <!-- Icone de som off -->
            <svg id="music-off-icon" xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                <path stroke-linecap="round" stroke-linejoin="round" d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" />
            </svg>
        </button>
        <button id="profile-btn" class="text-[#e5a938] bg-[#4a2c2a] p-2 rounded-full shadow-lg hover:bg-[#5a3c3a] transition-colors duration-200">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
            </svg>
        </button>
    </div>

    <!-- Container Principal (Aplica-se a Lobby e Auth) -->
    <div id="main-container" class="w-full min-h-screen md:min-h-0 md:h-auto md:max-w-4xl p-4 md:p-10 bg-[#f3e9d2] md:border-4 border-[#4a2c2a] md:rounded-lg md:shadow-xl relative">

        <!-- Overlay de Carregamento -->
        <div id="loading-overlay" class="absolute inset-0 bg-[#f3e9d2] bg-opacity-75 flex flex-col items-center justify-center rounded-lg z-50">
            <div class="loader ease-linear rounded-full border-8 border-t-8 border-[#4a2c2a] h-24 w-24"></div>
            <p class="mt-4 text-[#4a2c2a] font-bold animate-pulse">Carregando...</p>
        </div>

        <!-- Logo -->
        <div id="logo-container" class="flex justify-center mb-6">
            <img src="https://dl.dropbox.com/scl/fi/9303p8o5ubj1xkr9bovwo/logo-dado-do-mentiroso-2.png?rlkey=tsmt4tfqpuugljykjvxljq9t7&st=gpj40pb9&dl=0" alt="Logo do Jogo" class="w-64">
        </div>

        <!-- #0: View Inicial -->
        <div id="initial-view" class="hidden text-[#4a2c2a] max-w-md mx-auto flex flex-col gap-4">
            <button id="proceed-btn" class="w-full bg-[#003366] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md border-b-4 border-[#001a33]">Entrar</button>
            <button id="initial-how-to-play-btn" class="w-full bg-[#4a2c2a] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md border-b-4 border-[#2c1a1a]">Como Jogar</button>
        </div>

        <!-- #1: View de Autenticação -->
        <div id="auth-view" class="hidden text-[#4a2c2a] max-w-md mx-auto">
            <!-- Abas de Login / Cadastro -->
            <div id="auth-tabs-container" class="flex mb-4 border-b-2 border-[#4a2c2a]">
                <button id="tab-login" class="flex-1 py-2 text-center font-bold transition-all duration-200 border-b-4 border-[#e5a938] text-opacity-100">Login</button>
                <button id="tab-signup" class="flex-1 py-2 text-center font-bold transition-all duration-200 border-b-4 border-transparent text-opacity-60">Cadastrar</button>
            </div>

            <!-- Formulário de Login -->
            <form id="login-form">
                <div class="mb-4">
                    <label for="login-email" class="block text-sm font-bold mb-2">Email</label>
                    <input type="email" id="login-email" name="email" required autocomplete="username" class="w-full px-3 py-2 bg-[#f3e9d2] border-2 border-[#4a2c2a] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#e5a938]" placeholder="voce@email.com">
                </div>
                <div class="mb-6">
                    <label for="login-password" class="block text-sm font-bold mb-2">Senha</label>
                    <input type="password" id="login-password" name="password" required autocomplete="current-password" class="w-full px-3 py-2 bg-[#f3e9d2] border-2 border-[#4a2c2a] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#e5a938]" placeholder="••••••••">
                </div>
                <button type="submit" class="w-full bg-[#003366] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md border-b-4 border-[#001a33]">Entrar</button>
                <div class="text-center mt-4">
                    <a href="#" id="forgot-password-link" class="text-sm text-opacity-80 hover:text-opacity-100">Esqueci minha senha</a>
                </div>
            </form>

            <!-- Formulário de Cadastro (escondido por padrão) -->
            <form id="signup-form" class="hidden">
                <div class="mb-4">
                    <label for="signup-name" class="block text-sm font-bold mb-2">Nome</label>
                    <input type="text" id="signup-name" name="name" required maxlength="15" class="w-full px-3 py-2 bg-[#f3e9d2] border-2 border-[#4a2c2a] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#e5a938]" placeholder="Seu nome de jogador">
                </div>
                <div class="mb-4">
                    <label for="signup-email" class="block text-sm font-bold mb-2">Email</label>
                    <input type="email" id="signup-email" name="email" required class="w-full px-3 py-2 bg-[#f3e9d2] border-2 border-[#4a2c2a] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#e5a938]" placeholder="voce@email.com">
                </div>
                <div class="mb-6">
                    <label for="signup-password" class="block text-sm font-bold mb-2">Senha</label>
                    <input type="password" id="signup-password" name="password" required class="w-full px-3 py-2 bg-[#f3e9d2] border-2 border-[#4a2c2a] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#e5a938]" placeholder="Mínimo 6 caracteres">
                </div>
                <button type="submit" class="w-full bg-[#003366] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md border-b-4 border-[#001a33]">Criar Conta</button>
            </form>

            <!-- Formulário de Recuperação de Senha (escondido por padrão) -->
            <form id="reset-password-form" class="hidden">
                <div class="mb-4">
                    <label for="reset-email" class="block text-sm font-bold mb-2">Email</label>
                    <input type="email" id="reset-email" name="email" required class="w-full px-3 py-2 bg-[#f3e9d2] border-2 border-[#4a2c2a] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#e5a938]" placeholder="voce@email.com">
                </div>
                <button type="submit" class="w-full bg-[#003366] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md border-b-4 border-[#001a33]">Enviar Link de Recuperação</button>
                 <div class="text-center mt-4">
                    <a href="#" id="back-to-login-link" class="text-sm text-opacity-80 hover:text-opacity-100">Voltar para o Login</a>
                </div>
            </form>

            <!-- Formulário de Atualização de Senha (escondido por padrão) -->
            <form id="update-password-form" class="hidden">
                <p class="text-center mb-4">Defina sua nova senha.</p>
                <div class="mb-6">
                    <label for="update-password" class="block text-sm font-bold mb-2">Nova Senha</label>
                    <input type="password" id="update-password" name="password" required class="w-full px-3 py-2 bg-[#f3e9d2] border-2 border-[#4a2c2a] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#e5a938]" placeholder="••••••••">
                </div>
                <button type="submit" class="w-full bg-[#003366] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md border-b-4 border-[#001a33]">Atualizar Senha</button>
            </form>

            <!-- Mensagens de Auth -->
            <p id="auth-message" class="text-center text-sm mt-4"></p>
        </div>

        <!-- #2: View do Lobby (Logado) -->
        <div id="lobby-view" class="hidden text-[#4a2c2a] max-w-md mx-auto">
            <p id="welcome-message" class="text-center text-lg mb-6 font-bold"></p>

            <!-- Criar Sala -->
            <button id="create-room-btn" class="w-full bg-[#003366] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md mb-6 border-b-4 border-[#001a33]">
                Criar Nova Sala
            </button>

            <!-- Entrar na Sala -->
            <form id="join-room-form">
                <label for="room-code-input" class="block text-sm font-bold mb-2">Entrar em uma Sala</label>
                <div class="flex">
                    <input type="text" id="room-code-input" required class="flex-1 px-3 py-2 bg-[#f3e9d2] border-2 border-[#4a2c2a] rounded-l-lg focus:outline-none focus:ring-2 focus:ring-[#e5a938]" placeholder="Digite o código">
                    <button type="submit" class="bg-[#003366] text-white font-bold py-2 px-4 rounded-r-lg transition-transform transform hover:scale-105 border-b-4 border-t-2 border-r-2 border-[#001a33]">Entrar</button>
                </div>
            </form>
            <p id="lobby-message" class="text-center text-red-700 text-sm mt-4"></p>

            <!-- Botão Como Jogar (NOVO) -->
            <button id="how-to-play-btn" class="w-full bg-[#4a2c2a] text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md mt-6 border-b-4 border-[#2c1a1a]">Como Jogar</button>

            <!-- Logout -->
            <button id="logout-btn" class="w-full mt-8 text-red-800 hover:text-red-600 text-sm transition duration-300 font-bold">Sair</button>
        </div>

        <!-- #5: View "Como Jogar" (NOVO) -->
        <div id="how-to-play-view" class="hidden text-[#4a2c2a] prose max-w-2xl mx-auto">
            <h2 class="text-3xl font-bold text-center mb-4 font-title">Como Jogar</h2>

            <h3>Objetivo</h3>
            <p>O objetivo do "Dado do Mentiroso" é ser o último jogador com dados restantes. Você faz isso enganando seus oponentes e descobrindo quando eles estão mentindo sobre os dados na mesa.</p>

            <h3>O Jogo</h3>
            <ul>
                <li>Cada jogador começa com 5 dados de seis faces.</li>
                <li>No início de cada rodada, todos os jogadores rolam seus dados em segredo. Você só pode ver os seus próprios dados.</li>
                <li>O primeiro jogador faz um "lance" sobre a quantidade total de uma determinada face de dado entre TODOS os jogadores na mesa. Por exemplo, "Aposto que há três dados com a face 4".</li>
                <li>O próximo jogador tem duas opções:
                    <ol>
                        <li><strong>Aumentar o lance:</strong> Eles devem fazer um lance maior. Um lance é maior se a quantidade de dados for maior (ex: quatro 4s) ou se a quantidade for a mesma, mas a face do dado for maior (ex: três 5s).</li>
                        <li><strong>Duvidar:</strong> Se o jogador achar que o lance anterior é uma mentira, ele pode "duvidar".</li>
                    </ol>
                </li>
            </ul>

            <h3>Duvidando</h3>
            <p>Quando um jogador duvida, todos os dados são revelados:</p>
            <ul>
                <li>Se o lance era <strong>verdadeiro</strong> (havia pelo menos a quantidade de dados apostada), o jogador que duvidou perde um dado.</li>
                <li>Se o lance era <strong>falso</strong> (havia menos dados do que o apostado), o jogador que fez o lance perde um dado.</li>
            </ul>

            <h3>"Cravando" (Aposta Exata)</h3>
            <p>Em vez de duvidar, um jogador pode "cravar", acreditando que o lance anterior é exatamente o número de dados na mesa. Se estiverem certos, todos os outros jogadores perdem um dado. Se estiverem errados, eles perdem um dado.</p>

            <h3>Fim do Jogo</h3>
            <p>Um jogador é eliminado quando perde todos os seus dados. A última pessoa com dados restantes é a vencedora!</p>

            <button id="back-to-lobby-from-how-to-play-btn" class="w-full bg-[#003366] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md mt-6 border-b-4 border-[#001a33]">Voltar</button>
        </div>

        <!-- O CONTEÚDO DA SALA ABAIXO É REESTRUTURADO PARA O NOVO LAYOUT DE TELA CHEIA/JOGO -->

        <!-- #3: View da Sala (Dentro da Sala) -->
        <!-- "fixed" logic is handled inside game-view. room-view acts as a wrapper. -->
        <div id="room-view" class="hidden relative h-full flex flex-col text-[#f3e9d2]">
            
            <!-- CONTEÚDO DO LOBBY (VISÍVEL ANTES DE INICIAR O JOGO) -->
            <div id="lobby-wait-content" class="flex-1 p-4 overflow-y-auto max-w-2xl mx-auto">
                <h2 id="room-code-title" class="text-3xl text-center mb-4 font-title text-[#e5a938]">Código da Sala:</h2>
                <p id="room-code-display" class="text-5xl font-mono font-bold text-center text-[#4a2c2a] bg-[#f3e9d2] rounded-lg py-4 mb-6 border-4 border-[#4a2c2a]"></p>

                <h3 id="participants-title" class="text-2xl font-bold text-[#e5a938] mb-3">Quem está na sala:</h3>
                <ul id="participants-list" class="list-none list-inside bg-[#4a2c2a] bg-opacity-50 p-4 rounded-lg min-h-[120px] space-y-2 border-2 border-[#e5a938]">
                    <!-- Lista de participantes aparecerá aqui -->
                </ul>

                <!-- Controles do Jogo (Apenas para o Anfitrião) -->
                <div id="game-controls" class="mt-6"></div>
                
                <button id="leave-room-btn" class="w-full bg-[#f3e9d2] text-[#4a2c2a] font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md mt-6 border-b-4 border-[#c7b393]">Voltar ao Menu Principal</button>
            </div>
            
            <!-- TELA DO JOGO (VISÍVEL APÓS INICIAR O JOGO) -->
            <!-- Alterado para relativo e w-full para conter os elementos fixed corretamente -->
            <div id="game-view" class="hidden h-full w-full relative bg-[#3d2323]">
                
                <!-- A. Barra do Topo (FIXA NO TOPO) -->
                <div id="top-bar" class="fixed top-0 left-0 w-full px-4 bg-[#4a2c2a] text-[#f3e9d2] border-b-4 border-[#e5a938] shadow-lg z-30 flex justify-between items-center h-16">
                    <!-- Espaçador para manter o título centralizado -->
                    <div class="w-8"></div>
                    <div id="turn-info" class="flex-1 text-center text-2xl font-bold truncate font-title"></div>
                    <!-- Botão de Engrenagem (Configurações da Sala) -->
                    <button id="settings-btn" class="text-[#e5a938] bg-[#4a2c2a] p-2 rounded-full shadow-lg hover:bg-[#5a3c3a] transition-colors duration-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                            <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                    </button>
                </div>

                <!-- B. Histórico de Jogadas e Ações (ÁREA SCROLLÁVEL NO MEIO) -->
                <!-- pt-16 (altura do topo) e pb-[120px] (altura do rodapé de dados) -->
                <div id="history-container" class="absolute inset-0 pt-20 pb-[120px] overflow-y-auto w-full px-4">
                    <div id="history-messages" class="space-y-4 min-h-full flex flex-col justify-end py-4">
                        <!-- Mensagens de Lance e Turno (Chat-like) vão aqui -->
                    </div>

                    <!-- D. Controles de Ação (MOVIMIDO PARA CÁ) -->
                    <div id="bottom-actions" class="p-4 bg-[#f3e9d2] text-[#4a2c2a] border-t-4 border-[#4a2c2a] rounded-t-lg shadow-md mt-4 mx-auto max-w-md">
                        
                        <!-- Formulário de Lance (Botões) -->
                        <div id="bid-container" class="flex items-center justify-center gap-4 mb-4">
                            <!-- Seletor de Quantidade -->
                            <div class="flex items-center gap-2">
                                <button id="decrease-quantity-btn" class="px-3 py-1 bg-[#c7b393] rounded-md font-bold text-lg border-b-2 border-[#a1886c]">-</button>
                                <div class="flex flex-col items-center">
                                    <span class="text-sm">Dados</span>
                                    <span id="bid-quantity-display" class="w-12 text-center font-bold text-2xl">1</span>
                                </div>
                                <button id="increase-quantity-btn" class="px-3 py-1 bg-[#c7b393] rounded-md font-bold text-lg border-b-2 border-[#a1886c]">+</button>
                            </div>

                            <!-- Separador Visual -->
                            <div class="border-l h-10 border-[#4a2c2a]"></div>

                            <!-- Seletor de Face -->
                            <div class="flex items-center gap-2">
                                <button id="decrease-face-btn" class="px-3 py-1 bg-[#c7b393] rounded-md font-bold text-lg border-b-2 border-[#a1886c]">-</button>
                                <div class="flex flex-col items-center">
                                    <span class="text-sm">Face</span>
                                    <div id="bid-face-display" class="w-12 h-12 flex items-center justify-center">
                                        <svg class="w-10 h-10"><use href="#dice-1"></use></svg>
                                    </div>
                                </div>
                                <button id="increase-face-btn" class="px-3 py-1 bg-[#c7b393] rounded-md font-bold text-lg border-b-2 border-[#a1886c]">+</button>
                            </div>
                        </div>

                        <!-- Botões de Ações -->
                        <div class="flex gap-2">
                            <button id="bid-btn" class="flex-1 bg-[#003366] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md text-sm sm:text-base border-b-4 border-[#001a33]">Apostar</button>
                            <button id="challenge-btn" class="flex-1 bg-[#990000] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md text-sm sm:text-base border-b-4 border-[#660000]" disabled>Duvidar</button>
                            <button id="exact-btn" class="flex-1 bg-[#4a2c2a] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md text-sm sm:text-base border-b-4 border-[#2c1a1a]" disabled>Cravar</button>
                        </div>
                    </div>
                </div>

                <!-- CONTAINER FIXO DO RODAPÉ (APENAS DADOS) -->
                <div id="bottom-panel" class="fixed bottom-0 left-0 w-full z-30 bg-[#4a2c2a] shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.1)]">

                    <!-- C. Área dos Dados do Jogador -->
                    <div id="my-dice-area-container" class="p-4 bg-[#4a2c2a] border-t-4 border-[#e5a938]">
                        <h3 class="font-bold mb-2 text-sm text-center text-[#f3e9d2] font-title">Seus Dados</h3>
                        <div id="my-dice-display" class="flex justify-center items-center space-x-4 text-2xl h-10">
                            <!-- Dados do Jogador (SVGs) -->
                        </div>
                    </div>
                </div>

                <!-- Overlay de Resultado da Rodada (REDESENHADO) -->
                <div id="round-result-overlay" class="absolute inset-0 bg-[#3d2323] bg-opacity-95 flex flex-col items-center justify-center hidden p-4 z-50 text-[#f3e9d2] opacity-0 transition-opacity duration-700 ease-in">
                    <div class="bg-[#4a2c2a] p-8 rounded-2xl shadow-2xl w-full max-w-lg text-center border-t-8 border-b-8 border-[#e5a938]">
                        <h2 id="round-result-title" class="text-4xl font-extrabold text-[#e5a938] mb-2 font-title">Resultado da Rodada</h2>
                        <p id="round-result-message" class="text-lg mb-6 break-all"></p>
                        <div id="all-dice-reveal" class="mb-6 p-4 rounded-lg bg-[#3d2323] max-h-64 overflow-y-auto w-full space-y-3">
                            <!-- Dados de todos os jogadores serão mostrados aqui -->
                        </div>
                        <button id="close-round-result-btn" class="bg-[#e5a938] text-[#4a2c2a] font-bold py-3 px-8 rounded-lg transition-all duration-300 transform hover:scale-110 shadow-lg hover:shadow-[#e5a938]/50 text-lg border-b-4 border-[#c08e2a]">Fechar</button>
                        <!-- Botões de Fim de Jogo (escondidos por padrão) -->
                        <div id="end-game-buttons" class="hidden mt-4 space-y-2">
                             <button id="final-back-to-lobby-btn" class="bg-[#003366] text-white font-bold py-3 px-8 rounded-lg transition-all duration-300 transform hover:scale-110 shadow-lg text-lg border-b-4 border-[#001a33]">Sair</button>
                             <button id="final-leave-room-btn" class="bg-[#003366] text-white font-bold py-3 px-8 rounded-lg transition-all duration-300 transform hover:scale-110 shadow-lg text-lg border-b-4 border-[#001a33]">Sair</button>
                        </div>
                    </div>
                </div>

                <!-- Overlay de Anúncio da Ação (NOVO) -->
                <div id="round-action-overlay" class="absolute inset-0 bg-black flex flex-col items-center justify-center hidden p-6 z-50">
                    <div id="round-action-content" class="text-center">
                        <div id="round-action-message-container" class="text-4xl font-bold text-white font-title break-all flex flex-col items-center text-center" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.7);">
                            <span id="action-player-1"></span>
                            <span id="action-verb" class="block my-2 text-red-500 italic"></span>
                            <span id="action-player-2"></span>
                        </div>
                    </div>
                </div>

                 <!-- Overlay de Fim de Jogo -->
                 <div id="game-over-overlay" class="absolute inset-0 bg-[#f3e9d2] bg-opacity-95 flex flex-col items-center justify-center hidden p-4 z-50 text-[#4a2c2a]">
                    <h2 id="winner-message" class="text-4xl font-bold mb-4 text-center font-title"></h2>
                    <p class="mb-6 text-lg">O jogo terminou.</p>
                    <button id="back-to-lobby-btn" class="bg-[#003366] text-white font-bold py-3 px-6 rounded-lg transition-transform transform hover:scale-105 shadow-md border-b-4 border-[#001a33]">Voltar a sala de espera</button>
                </div>
            </div>
            
        </div>
    </div>

    <!-- #4: Modal de Configurações -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-[#f3e9d2] text-[#4a2c2a] rounded-lg shadow-xl p-6 w-full max-w-sm relative overflow-y-auto max-h-full border-4 border-[#4a2c2a]">
            <!-- Botão de Fechar (Principal) -->
            <button id="close-modal-btn" class="absolute top-0 right-0 mt-2 mr-2 text-[#4a2c2a] hover:text-red-800 z-10">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>

            <!-- View de Informações da Sala (Escondida por Padrão) -->
            <div id="settings-room-view" class="hidden">
                <h2 class="text-3xl font-bold text-center mb-4 font-title">Informação da Sala</h2>
                <!-- Código da Sala -->
                <div class="mb-4">
                    <p class="font-bold">Código da Sala:</p>
                    <p id="modal-room-code" class="text-2xl font-mono"></p>
                </div>
                <!-- Anfitrião -->
                <div id="modal-host-info" class="mb-4">
                    <p class="font-bold">Anfitrião:</p>
                    <p id="modal-host-name" class="font-bold"></p>
                </div>
                <!-- Round -->
                <div id="modal-round-info" class="mb-4 hidden">
                    <p class="font-bold">Rodada Atual:</p>
                    <p id="modal-round-number" class="font-bold"></p>
                </div>
                <!-- Jogadores -->
                <div id="modal-players-info" class="mb-6">
                    <p class="font-bold">Jogadores:</p>
                    <ul id="modal-participants-list" class="list-disc list-inside space-y-1 mt-1">
                        <!-- Lista de jogadores no modal -->
                    </ul>
                </div>
                <!-- Controles do Anfitrião (dentro do modal) -->
                <div id="modal-host-controls" class="space-y-2 mb-4 hidden">
                    <button id="end-game-btn" class="w-full bg-[#990000] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md border-b-4 border-[#660000]">Finalizar Jogo</button>
                </div>
                <!-- Botão de Sair -->
                <button id="modal-logout-btn" class="w-full bg-[#4a2c2a] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md mb-4 border-b-4 border-[#2c1a1a]">Sair da sala</button>
            </div>

            <!-- View de Configuração da Conta (Escondida por Padrão, conteúdo virá do #profile-modal) -->
            <div id="settings-account-view" class="hidden">
                <h2 class="text-3xl font-bold text-center mb-6 font-title">Configuração da Conta</h2>
                <!-- Formulário de Troca de Nome -->
                <form id="change-name-form" class="mb-6">
                    <div class="mb-4">
                        <label for="new-name" class="block text-sm font-bold mb-2">Novo Nome</label>
                        <input type="text" id="new-name" required maxlength="15" class="w-full px-3 py-2 bg-[#f3e9d2] border-2 border-[#4a2c2a] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#e5a938]" placeholder="Novo nome de jogador">
                    </div>
                    <button type="submit" class="w-full bg-[#003366] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md border-b-4 border-[#001a33]">Salvar Novo Nome</button>
                </form>
                <!-- Formulário de Troca de Senha -->
                <form id="change-password-form">
                    <div class="mb-4">
                        <label for="new-password" class="block text-sm font-bold mb-2">Nova Senha</label>
                        <input type="password" id="new-password" required class="w-full px-3 py-2 bg-[#f3e9d2] border-2 border-[#4a2c2a] rounded-lg focus:outline-none focus:ring-2 focus:ring-[#e5a938]" placeholder="••••••••">
                    </div>
                    <button type="submit" class="w-full bg-[#003366] text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105 shadow-md border-b-4 border-[#001a33]">Salvar Nova Senha</button>
                </form>
                <p id="profile-message" class="text-center text-sm mt-4"></p>
            </div>
        </div>
    </div>

    <!-- Notificação Toast -->
    <div id="toast-notification" class="fixed top-5 left-5 bg-[#4a2c2a] text-[#f3e9d2] py-2 px-4 rounded-lg shadow-lg hidden transition-opacity duration-300 z-[60] border-2 border-[#e5a938]">
        <p id="toast-message"></p>
    </div>

    <script>
        // Expor utilitários de teste PRIMEIRO para garantir que estejam disponíveis
        window.testUtils = {
            setState: (newState) => {
                if (!newState) {
                    currentUser = null;
                    currentRoom = null;
                    room = null;
                    gameState = null;
                    presences = {};
                    return;
                }
                if (newState.currentUser !== undefined) currentUser = newState.currentUser;
                if (newState.currentRoom !== undefined) currentRoom = newState.currentRoom;
                if (newState.room !== undefined) room = newState.room;
                if (newState.gameStarted !== undefined) gameStarted = newState.gameStarted;
                if (newState.gameState !== undefined) gameState = newState.gameState;
                if (newState.presences !== undefined) presences = newState.presences;
                if (newState.currentView !== undefined) {
                    currentView = newState.currentView;
                    showView(currentView);
                }
                renderRoomUI();
                renderGameUI();
            }
        };

        let audioCtx = null;
        const SoundEngine = {
            bgMusic: null,
            isMuted: false,
            init() {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (!this.bgMusic) {
                    this.bgMusic = new Audio('https://www.dropbox.com/scl/fi/1mntmg3c8ugwtrnsz19az/pan-captain-hook-theme-33481.mp3?rlkey=y6y82dgy94tknomh5k8gf4c7f&st=jigw1p8r&dl=1');
                    this.bgMusic.loop = true;
                    this.bgMusic.volume = 0.4;
                }
            },
            updateBGMusic() {
                this.init();
                // A música só toca se NÃO estiver no jogo e NÃO estiver silenciada
                const shouldPlay = !gameStarted && !this.isMuted;
                if (shouldPlay) {
                    this.bgMusic.play().catch(e => console.warn("Erro ao tocar música de fundo:", e));
                } else {
                    this.bgMusic.pause();
                }
            },
            toggleMusic() {
                this.isMuted = !this.isMuted;
                this.updateBGMusic();
                // Atualiza o ícone do botão
                const onIcon = document.getElementById('music-on-icon');
                const offIcon = document.getElementById('music-off-icon');
                if (onIcon && offIcon) {
                    onIcon.classList.toggle('hidden', this.isMuted);
                    offIcon.classList.toggle('hidden', !this.isMuted);
                }
            },
            play(type) {
                this.init();
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                const now = audioCtx.currentTime;

                if (type === 'dice-sound') {
                    const diceAudio = new Audio('https://dl.dropbox.com/scl/fi/dhwfowme1nwmppdqu5y4g/dice.mp3?rlkey=cclq6ci60apo97o9bawl1wbff&st=70cl8hiu&dl=1');
                    diceAudio.play().catch(e => console.warn("Erro ao tocar som de dados:", e));
                    return;
                }
                if (type === 'win-sound') {
                    [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                        const o = audioCtx.createOscillator();
                        const g = audioCtx.createGain();
                        o.connect(g); g.connect(audioCtx.destination);
                        const t = now + i * 0.1;
                        o.type = 'sine';
                        o.frequency.setValueAtTime(freq, t);
                        g.gain.setValueAtTime(0.15, t);
                        g.gain.linearRampToValueAtTime(0, t + 0.6);
                        o.start(t); o.stop(t + 0.6);
                    });
                    return;
                }

                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                switch (type) {
                    case 'click-sound':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(800, now);
                        oscillator.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                        gainNode.gain.setValueAtTime(0.1, now);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        oscillator.start(now);
                        oscillator.stop(now + 0.1);
                        break;
                    case 'transition-sound':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(300, now);
                        oscillator.frequency.exponentialRampToValueAtTime(600, now + 0.2);
                        gainNode.gain.setValueAtTime(0.05, now);
                        gainNode.gain.linearRampToValueAtTime(0, now + 0.2);
                        oscillator.start(now);
                        oscillator.stop(now + 0.2);
                        break;
                    case 'challenge-sound':
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(180, now);
                        oscillator.frequency.linearRampToValueAtTime(120, now + 0.3);
                        gainNode.gain.setValueAtTime(0.05, now);
                        gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                        oscillator.start(now);
                        oscillator.stop(now + 0.3);
                        break;
                    case 'exact-sound':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(500, now);
                        oscillator.frequency.exponentialRampToValueAtTime(1000, now + 0.2);
                        gainNode.gain.setValueAtTime(0.1, now);
                        gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                        oscillator.start(now);
                        oscillator.stop(now + 0.3);
                        break;
                    case 'lose-die-sound':
                        oscillator.type = 'triangle';
                        oscillator.frequency.setValueAtTime(400, now);
                        oscillator.frequency.exponentialRampToValueAtTime(60, now + 0.5);
                        gainNode.gain.setValueAtTime(0.2, now);
                        gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
                        oscillator.start(now);
                        oscillator.stop(now + 0.5);
                        break;
                    case 'enter-room-sound':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(440, now);
                        oscillator.frequency.exponentialRampToValueAtTime(880, now + 0.15);
                        gainNode.gain.setValueAtTime(0.1, now);
                        gainNode.gain.linearRampToValueAtTime(0, now + 0.15);
                        oscillator.start(now);
                        oscillator.stop(now + 0.15);
                        break;
                    case 'leave-room-sound':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(880, now);
                        oscillator.frequency.exponentialRampToValueAtTime(440, now + 0.15);
                        gainNode.gain.setValueAtTime(0.1, now);
                        gainNode.gain.linearRampToValueAtTime(0, now + 0.15);
                        oscillator.start(now);
                        oscillator.stop(now + 0.15);
                        break;
                }
            }
        };

        /**
         * Reproduz um som sintetizado pelo ID.
         * @param {string} id - O identificador do som.
         */
        function playSound(id) {
            SoundEngine.play(id);
        }

        // Ouvinte global para adicionar som discreto a todos os botões do jogo
        document.addEventListener('click', (e) => {
            // Garante que a música de fundo comece após a primeira interação do usuário
            SoundEngine.updateBGMusic();

            const target = e.target.closest('button') || (e.target.tagName === 'A' ? e.target : null);
            if (target) {
                playSound('click-sound');
            }
        });

        // --- 1. LÓGICA DE ESTADO de JOGO ---
        /**
         * Cria o estado inicial do jogo para uma lista de jogadores.
         * Esta função é a fonte da verdade para um novo jogo.
         */
        function createInitialGameState(playerIds, firstPlayerId) {
            const players = {};
            playerIds.forEach(id => {
                players[id] = {
                    diceCount: 5, // Cada jogador começa com 5 dados
                    dice: [],     // Os dados rolados serão armazenados aqui
                };
            });

            return {
                players: players,
                turnOrder: [], // Armazena a ordem dos turnos dos jogadores
                currentPlayer: firstPlayerId,
                currentBid: null,
                lastBidder: null,
                turn: 1,
                round: 1,
                gameWinner: null,
                bidHistory: [], // NOVO: Armazena o histórico de lances
                currentTurnMessage: '',
                roundInfo: {
                    phase: 'bidding', // Fases: 'bidding', 'challenged', 'exact_bid', 'reveal'
                    actionTaker: null, // ID do jogador que iniciou a ação (duvidou ou cravou)
                    bidder: null,
                    challenger: null,
                    loser: null,
                    losers: [], // Para o caso de acerto exato
                    actualQuantity: 0,
                    message: '',
                },
            };
        }

        // --- 2. CONFIGURAÇÃO DO SUPABASE ---
        const SUPABASE_URL = 'https://jwvkewueqtjwtuglfmhi.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imp3dmtld3VlcXRqd3R1Z2xmbWhpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEyMjgyOTUsImV4cCI6MjA3NjgwNDI5NX0.M36XSfa6aWGGKOstV7pdT7qNlNsZD6RhUW7ng9OA0UA';

        if (SUPABASE_URL === 'SEU_SUPABASE_URL' || SUPABASE_ANON_KEY === 'SUA_SUPABASE_ANON_KEY') {
            document.getElementById('auth-view').innerHTML = `<p class="text-center text-red-400">Por favor, configure sua URL e Chave Anônima do Supabase.</p>`;
        }

        const { createClient } = supabase;
        const sb = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
            auth: {
                persistSession: true,
                autoRefreshToken: true,
                detectSessionInUrl: true
            }
        });

        // --- 2. REFERÊNCIAS DO DOM ---
        const loadingOverlay = document.getElementById('loading-overlay');
        const authView = document.getElementById('auth-view');
        const lobbyView = document.getElementById('lobby-view');
        const howToPlayView = document.getElementById('how-to-play-view'); // Novo
        const roomView = document.getElementById('room-view');
        const tabLogin = document.getElementById('tab-login');
        const tabSignup = document.getElementById('tab-signup');
        const loginForm = document.getElementById('login-form');
        const signupForm = document.getElementById('signup-form');
        const resetPasswordForm = document.getElementById('reset-password-form');
        const updatePasswordForm = document.getElementById('update-password-form');
        const forgotPasswordLink = document.getElementById('forgot-password-link');
        const backToLoginLink = document.getElementById('back-to-login-link');
        const joinRoomForm = document.getElementById('join-room-form');
        const authMessage = document.getElementById('auth-message');
        const topRightControls = document.getElementById('top-right-controls'); // Controles de música e perfil
        const musicToggleBtn = document.getElementById('music-toggle-btn');
        const lobbyMessage = document.getElementById('lobby-message');
        const welcomeMessage = document.getElementById('welcome-message');
        const createRoomBtn = document.getElementById('create-room-btn');
        const logoContainer = document.getElementById('logo-container');
        const changePasswordForm = document.getElementById('change-password-form');
        const changeNameForm = document.getElementById('change-name-form');
        const profileMessage = document.getElementById('profile-message');
        const logoutBtn = document.getElementById('logout-btn');
        const howToPlayBtn = document.getElementById('how-to-play-btn'); // Novo
        const backToLobbyFromHowToPlayBtn = document.getElementById('back-to-lobby-from-how-to-play-btn'); // Novo
        const leaveRoomBtn = document.getElementById('leave-room-btn');
        const roomCodeDisplay = document.getElementById('room-code-display');
        const roomCodeInput = document.getElementById('room-code-input');
        const participantsList = document.getElementById('participants-list');
        const pageBody = document.getElementById('page-body');
        const mainContainer = document.getElementById('main-container');
        const roomCodeTitle = document.getElementById('room-code-title');
        const participantsTitle = document.getElementById('participants-title');
        const lobbyWaitContent = document.getElementById('lobby-wait-content'); // Novo
        // Referência da Notificação Toast
        const toastNotification = document.getElementById('toast-notification');
        const toastMessage = document.getElementById('toast-message');
        // Referências do Modal de Configurações (Refatorado)
        const profileBtn = document.getElementById('profile-btn'); // Novo
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const settingsRoomView = document.getElementById('settings-room-view');
        const settingsAccountView = document.getElementById('settings-account-view');
        const modalRoomCode = document.getElementById('modal-room-code');
        const modalHostName = document.getElementById('modal-host-name');
        const modalParticipantsList = document.getElementById('modal-participants-list');
        const modalLogoutBtn = document.getElementById('modal-logout-btn');
        // Referências dos Controles do Anfitrião no Modal
        const modalHostControls = document.getElementById('modal-host-controls');
        const endGameBtn = document.getElementById('end-game-btn');
        // Referências da UI do Jogo
        const gameView = document.getElementById('game-view');
        const bidBtn = document.getElementById('bid-btn');
        const challengeBtn = document.getElementById('challenge-btn');
        const exactBtn = document.getElementById('exact-btn');
        const closeRoundResultBtn = document.getElementById('close-round-result-btn');
        const backToLobbyBtn = document.getElementById('back-to-lobby-btn');
        // Overlays e Sons para Animação
        const roundActionOverlay = document.getElementById('round-action-overlay');
        const roundActionContent = document.getElementById('round-action-content');
        const roundActionMessage = document.getElementById('round-action-message');
        // Novos Elementos da UI do Jogo (Estrutura V2)
        const roundNumberDisplay = document.getElementById('round-number'); // Movido
        const myDiceDisplay = document.getElementById('my-dice-display'); // Movido
        const historyMessages = document.getElementById('history-messages'); // Novo
        const historyContainer = document.getElementById('history-container'); // Novo para rolagem
        // Referências dos Controles de Lance
        const bidQuantityDisplay = document.getElementById('bid-quantity-display');
        const bidFaceDisplay = document.getElementById('bid-face-display');
        const increaseQuantityBtn = document.getElementById('increase-quantity-btn');
        const decreaseQuantityBtn = document.getElementById('decrease-quantity-btn');
        const increaseFaceBtn = document.getElementById('increase-face-btn');
        const decreaseFaceBtn = document.getElementById('decrease-face-btn');

        // --- 3. ESTADO DA APLICAÇÃO ---
        let currentUser = null;
        let lastMainView = 'initial-view';
        let currentRoomChannel = null;
        let currentBidInput = { quantity: 1, face: 1 }; // Estado local para a UI de lance
        let currentRoom = null;
        let gameStarted = false;
        let gameState = null;
        let presences = {};
        let channelSubscribedAt = null; // Rastreia o tempo de inscrição para evitar condições de corrida
        let nextRoundTimeoutId = null; // Rastreia o temporizador para a próxima rodada automática

        // --- 4. FUNÇÕES AUXILIARES ---
        function timeout(ms, message = 'A operação demorou muito e foi cancelada.') {
            return new Promise((_, reject) => {
                setTimeout(() => {
                    reject(new Error(message));
                }, ms);
            });
        }
        function toggleLoading(isLoading) { loadingOverlay.classList.toggle('hidden', !isLoading); }
        function showAuthMessage(message, isError = false) { authMessage.textContent = message; authMessage.className = `text-center text-sm mt-4 ${isError ? 'text-red-400' : 'text-green-400'}`; }
        function showLobbyMessage(message, isError = true) { lobbyMessage.textContent = message; lobbyMessage.className = `text-center text-sm mt-4 ${isError ? 'text-red-400' : 'text-green-400'}`; }
        function showView(viewId) {
            playSound('transition-sound');
            SoundEngine.updateBGMusic();

            if (viewId !== 'how-to-play-view') {
                lastMainView = viewId;
            }

            ['initial-view', 'auth-view', 'lobby-view', 'room-view', 'how-to-play-view'].forEach(id => document.getElementById(id).classList.add('hidden'));
            document.getElementById(viewId).classList.remove('hidden');

            // Controla a visibilidade dos botões de configuração com base na view
            // Agora visível no Login e Lobby
            const isAuthOrLobby = viewId === 'auth-view' || viewId === 'lobby-view' || viewId === 'initial-view';
            topRightControls.classList.toggle('hidden', !isAuthOrLobby);

            // O botão de perfil só aparece se o usuário estiver logado
            if (profileBtn) {
                profileBtn.classList.toggle('hidden', !currentUser);
            }
        }
        function generateRoomCode() { return Math.floor(Math.random() * 900000 + 100000).toString(); }

        let toastTimeout;
        function showToast(message) {
            // Limpa qualquer notificação anterior para evitar sobreposição
            clearTimeout(toastTimeout);
            toastMessage.textContent = message;
            toastNotification.classList.remove('hidden');
            // A notificação desaparecerá após 3 segundos
            toastTimeout = setTimeout(() => {
                toastNotification.classList.add('hidden');
            }, 3000);
        }

        function setRoomViewMode(isFullScreen) {
            const mc = mainContainer.classList;
            const body = pageBody.classList;

            logoContainer.classList.toggle('hidden', isFullScreen);

            if (isFullScreen) {
                // FORÇA O MODO DE TELA CHEIA
                // Remove todas as classes de layout responsivo e de cartão
                mc.remove('md:min-h-0', 'md:h-auto', 'md:max-w-4xl', 'p-4', 'md:p-10', 'md:border-4', 'md:rounded-lg', 'md:shadow-xl');
                body.remove('md:items-center', 'md:justify-center');

                // Adiciona classes para forçar altura e largura total
                mc.add('h-screen', 'w-full', 'p-0');

            } else {
                // RESTAURA O MODO DE CARTÃO RESPONSIVO
                // Remove as classes de tela cheia
                mc.remove('h-screen', 'p-0');

                // Adiciona de volta todas as classes de layout responsivo e de cartão
                mc.add('md:min-h-0', 'md:h-auto', 'md:max-w-4xl', 'p-4', 'md:p-10', 'md:border-4', 'md:rounded-lg', 'md:shadow-xl');
                body.add('md:items-center', 'md:justify-center');
            }
        }

        async function saveUserCurrentRoom(roomCode) {
            if (!currentUser) return;
            try {
                const { error } = await Promise.race([
                    sb.from('profiles').update({ last_room: roomCode }).eq('id', currentUser.id),
                    timeout(5000, 'A atualização do perfil demorou muito.')
                ]);
                if (error) console.error('Erro ao salvar sala no perfil:', error.message);
            } catch (err) {
                console.error('Erro de timeout ao salvar sala no perfil:', err.message);
            }
        }
        async function clearUserCurrentRoom() { await saveUserCurrentRoom(null); }

        function renderRoomUI() {
            if (!currentRoom || !currentUser) return;

            const isHost = currentUser.id === currentRoom.creator_id;

            // Controla a visibilidade dos elementos com base no estado do jogo
            const showLobby = !gameStarted && !gameState?.gameWinner;

            // Centraliza a lógica de alternância de visualização aqui
            setRoomViewMode(!showLobby);

            if (showLobby) {
                lobbyWaitContent.classList.remove('hidden');
                gameView.classList.add('hidden');
                settingsBtn.classList.add('hidden'); // Esconde o botão de engrenagem no lobby
            } else {
                lobbyWaitContent.classList.add('hidden');
                gameView.classList.remove('hidden');
                settingsBtn.classList.remove('hidden'); // Mostra o botão de engrenagem no jogo
            }

            const gameControlsContainer = document.getElementById('game-controls');
            gameControlsContainer.innerHTML = '';


            if (showLobby && isHost) {
                const gameButton = document.createElement('button');
                gameButton.id = 'game-action-btn';
                gameButton.textContent = 'Iniciar Jogo';
                gameButton.className = 'w-full font-bold py-2 px-4 rounded-lg transition duration-300 bg-black text-white hover:bg-gray-800';
                gameButton.addEventListener('click', handleGameAction);

                const participantCount = Object.keys(presences).length;
                if (participantCount < 2) {
                    gameButton.disabled = true;
                    gameButton.textContent = 'Aguardando mais jogadores...';
                    gameButton.classList.add('opacity-50', 'cursor-not-allowed');
                }
                gameControlsContainer.appendChild(gameButton);
            } else if (showLobby && !isHost) {
                // Se não for o anfitrião, exibe uma mensagem
                gameControlsContainer.innerHTML = '<p class="text-center text-gray-500">Aguardando o anfitrião iniciar o jogo...</p>';
            }
        }

        // --- 6. LÓGICA DE JOGO E ANFITRIÃO ---
        /**
         * Atualiza o estado do jogo localmente, renderiza a UI e transmite para outros jogadores.
         * Isso garante que a UI do remetente seja atualizada imediatamente.
         * @param {object} newGameState - O objeto de estado completo do jogo a ser transmitido.
         * @param {boolean} newGameStarted - O estado de "jogo iniciado".
         */
        async function updateAndBroadcastGameState(newGameState, newGameStarted, reason = null) {
            if (currentRoomChannel) {
                try {
                    await Promise.race([
                        currentRoomChannel.send({
                            type: 'broadcast',
                            event: 'game_state_update',
                            payload: { gameState: newGameState, gameStarted: newGameStarted, reason: reason },
                        }),
                        timeout(5000, 'A transmissão do estado do jogo demorou muito.')
                    ]);
                } catch (error) {
                    console.error('Falha ao transmitir o estado do jogo:', error.message);
                    // Lança o erro novamente para que as funções chamadoras possam lidar com ele.
                    // Isso é importante para que o chamador possa parar o indicador de carregamento.
                    throw error;
                }
            }
        }

        async function handleGameAction() {
            if (!currentRoomChannel || !currentUser || currentUser.id !== currentRoom.creator_id) return;

            // Limpa qualquer temporizador de rodada pendente para evitar transições inesperadas
            if (nextRoundTimeoutId) {
                clearTimeout(nextRoundTimeoutId);
                nextRoundTimeoutId = null;
            }

            const playerIds = Object.keys(presences);
            if (playerIds.length < 2) {
                showLobbyMessage("São necessários pelo menos 2 jogadores para começar.", true);
                return;
            }

            toggleLoading(true); // Mostra o carregamento
            try {
                // 1. Atualiza o banco de dados para marcar o jogo como iniciado.
                const { error } = await Promise.race([
                    sb.from('rooms').update({ game_started: true }).eq('room_code', currentRoom.room_code),
                    timeout(10000, 'A inicialização do jogo no servidor demorou muito.')
                ]);
                if (error) {
                    throw new Error(`Erro ao iniciar o jogo: ${error.message}`);
                }

                // 2. Cria o estado inicial do jogo.
                playerIds.sort();
                const newGameState = createInitialGameState(playerIds, playerIds[0]);
                newGameState.turnOrder = playerIds;
                const firstPlayerName = presences[newGameState.currentPlayer]?.[0].name || presences[newGameState.currentPlayer]?.[0].email || '...';
                newGameState.currentTurnMessage = `É a vez de ${firstPlayerName}.`;

                for (const playerId in newGameState.players) {
                    const player = newGameState.players[playerId];
                    player.dice = Array.from({ length: player.diceCount }, () => Math.floor(Math.random() * 6) + 1);
                }

                // 3. Transmite o novo estado. A UI será atualizada pelo ouvinte de broadcast.
                await updateAndBroadcastGameState(newGameState, true);

            } catch (err) {
                console.error("Erro ao iniciar o jogo:", err);
                showLobbyMessage(err.message, true);
                // Se ocorrer um erro, esconde o carregamento.
                // Caso contrário, o ouvinte de 'game_state_update' irá escondê-lo.
                toggleLoading(false);
            }
        }

        const diceSVGTags = {
            1: '<svg class="w-8 h-8"><use href="#dice-1"></use></svg>',
            2: '<svg class="w-8 h-8"><use href="#dice-2"></use></svg>',
            3: '<svg class="w-8 h-8"><use href="#dice-3"></use></svg>',
            4: '<svg class="w-8 h-8"><use href="#dice-4"></use></svg>',
            5: '<svg class="w-8 h-8"><use href="#dice-5"></use></svg>',
            6: '<svg class="w-8 h-8"><use href="#dice-6"></use></svg>',
        };

        function renderGameUI() {
            // Garante que todos os overlays do jogo estejam escondidos por padrão.
            // Eles serão reexib-idos apenas se o estado atual do jogo o justificar.
            document.getElementById('game-over-overlay').classList.add('hidden');
            roundActionOverlay.classList.add('hidden');

            // Oculta o overlay de resultado da rodada apenas se o jogo for resetado ou uma nova partida começar.
            const roundResultOverlay = document.getElementById('round-result-overlay');
            if (!gameState || (gameState.round === 1 && gameState.turn === 1 && gameState.roundInfo?.phase !== 'reveal')) {
                roundResultOverlay.classList.add('hidden');
                roundResultOverlay.classList.add('opacity-0');
            }

            // Se não houver jogo em andamento, não há mais nada a fazer.
            if (!gameState || !currentUser) return;

            const { players, currentPlayer, currentBid, round, roundInfo, gameWinner } = gameState;
            const myPlayerState = players[currentUser.id];


            // 2. Lógica de Fases da Rodada (NOVO)
            const currentPhase = roundInfo.phase;

            if (currentPhase === 'challenged' || currentPhase === 'exact_bid') {
                const actionTakerName = presences[roundInfo.actionTaker]?.[0].name || 'Jogador';
                const bidderName = presences[roundInfo.bidder]?.[0].name || 'Jogador';
                let actionVerb = '';

                if (currentPhase === 'challenged') {
                    actionVerb = 'duvidou de';
                    playSound('challenge-sound');
                } else { // exact_bid
                    actionVerb = 'cravou a aposta de';
                    playSound('exact-sound');
                }

                // Preenche a nova estrutura
                document.getElementById('action-player-1').textContent = actionTakerName;
                document.getElementById('action-verb').textContent = actionVerb;
                document.getElementById('action-player-2').textContent = bidderName + '!';

                roundActionOverlay.classList.remove('hidden');

                // Orquestração da nova animação
                const messageContainer = document.getElementById('round-action-message-container');

                // Garante que o estado inicial está limpo
                messageContainer.classList.remove('animate-slide-in-from-left', 'animate-fade-out');

                // 1. Animação de entrada (slide in)
                messageContainer.classList.add('animate-slide-in-from-left');

                // 2. Animação de saída (fade out) após um tempo
                setTimeout(() => {
                    messageContainer.classList.remove('animate-slide-in-from-left');
                    messageContainer.classList.add('animate-fade-out');
                }, 1800); // Espera 1.8s antes de começar a desaparecer

                // Não renderiza o resto da UI do jogo durante a animação
                return;
            }

            if (currentPhase === 'reveal') {
                const roundResultOverlay = document.getElementById('round-result-overlay');
                document.getElementById('round-result-message').innerHTML = roundInfo.message; // Use innerHTML to render styled spans
                const allDiceReveal = document.getElementById('all-dice-reveal');
                allDiceReveal.innerHTML = '';

                const diceByPlayer = {};
                for (const pId in players) {
                    diceByPlayer[pId] = players[pId].dice;
                }
                const loserIds = roundInfo.losers || [];

                for (const playerId in diceByPlayer) {
                    const playerName = presences[playerId]?.[0].name || presences[playerId]?.[0].email || 'Jogador';
                    const isLoser = loserIds.includes(playerId);
                    const diceArray = diceByPlayer[playerId];
                    let diceHtml = '';

                    diceArray.forEach((d, index) => {
                        const dieSvg = diceSVGTags[d].replace('class="w-8 h-8"', 'class="w-10 h-10"'); // Aumenta o dado
                        // Se for o perdedor E este for o último dado, aplica a animação de explosão
                        if (isLoser && index === diceArray.length - 1) {
                            diceHtml += `<div class="inline-block dice-explode-animation">${dieSvg}</div>`;
                        } else {
                            diceHtml += `<div class="inline-block">${dieSvg}</div>`;
                        }
                    });

                    const containerClasses = isLoser
                        ? 'p-3 rounded-lg bg-red-800/50 border border-red-600 shadow-inner'
                        : 'p-3 rounded-lg bg-gray-600';

                    allDiceReveal.innerHTML += `<div class="${containerClasses}"><p class="font-bold text-white mb-2">${playerName}:</p><div class="flex justify-center gap-2">${diceHtml}</div></div>`;
                }

                const remainingPlayersWithDice = Object.values(players).filter(p => p.diceCount > 0).length;

                const isHost = currentUser && currentRoom && currentUser.id === currentRoom.creator_id;
                const isGameOver = remainingPlayersWithDice < 2;

                // Control button visibility based on game state
                document.getElementById('close-round-result-btn').classList.toggle('hidden', isGameOver);
                document.getElementById('end-game-buttons').classList.toggle('hidden', !isGameOver);
                document.getElementById('final-back-to-lobby-btn').classList.toggle('hidden', !isGameOver || !isHost);
                document.getElementById('final-leave-room-btn').classList.toggle('hidden', !isGameOver || isHost);

                if (isGameOver) {
                    document.getElementById('round-result-title').textContent = "Fim de Jogo!";
                } else {
                    document.getElementById('round-result-title').textContent = "Resultado da Rodada";
                }

                roundResultOverlay.classList.remove('hidden');

                // Adiciona o efeito de fade-in
                setTimeout(() => {
                    roundResultOverlay.classList.remove('opacity-0');
                }, 100); // Pequeno delay para garantir a transição

                return; // Pausa a renderização do resto da UI do jogo
            }


            // 3. Atualiza a Barra do Topo
            const turnInfo = document.getElementById('turn-info');
            if (currentUser.id === gameState.currentPlayer) {
                turnInfo.textContent = 'É a sua vez';
            } else {
                // Constrói a mensagem de turno dinamicamente para garantir que o nome esteja sempre atualizado
                const cpPresence = presences[gameState.currentPlayer]?.[0];
                const cpName = cpPresence?.name || cpPresence?.email || '...';
                turnInfo.textContent = `É a vez de ${cpName}.`;
            }

            // 4. Atualiza o Histórico de Jogadas (Chat-like)
            historyMessages.innerHTML = '';
            gameState.bidHistory.filter(item => item.type === 'bid').forEach((item, index) => {
                const msgDiv = document.createElement('div');

                // Define classes de estilo com base no tipo de mensagem
                let baseClasses = "p-3 rounded-lg w-full ";
                const bidderName = presences[item.playerId]?.[0].name || 'Jogador';
                const isSelf = item.playerId === currentUser.id;
                msgDiv.className = baseClasses + (isSelf ? 'bg-blue-100 border border-blue-200' : 'bg-white shadow-sm border border-gray-200');
                const bidHtml = `<p class="text-sm font-semibold ${isSelf ? 'text-blue-800' : 'text-gray-800'}">${bidderName}:</p>
                                     <div class="flex items-center gap-1 mt-1">
                                         <span class="text-gray-600 text-sm">Apostou: </span>
                                         <span class="font-bold text-lg text-gray-900">${item.quantity} x</span>
                                         ${diceSVGTags[item.face]}
                                     </div>`;
                msgDiv.innerHTML = bidHtml;

                historyMessages.appendChild(msgDiv);
            });

            // 5. Atualiza os dados do jogador atual
            myDiceDisplay.innerHTML = '';
            // Cláusula de guarda: Renderiza os dados apenas se o jogador estiver
            // ativo no estado do jogo. Isso evita erros se a UI for renderizada
            // para um jogador que acabou de sair ou foi eliminado.
            if (myPlayerState) {
                // A animação e o som devem ocorrer apenas quando os dados são "rolados",
                // ou seja, no início de uma nova rodada (quando o turno é 1).
                const isNewRound = gameState.turn === 1;

                if (isNewRound) {
                    playSound('dice-sound');
                }

                myPlayerState.dice.forEach(d => {
                    const dieDiv = document.createElement('div');
                    // Define as classes do SVG: sempre maiores, mas animados apenas em uma nova rodada.
                    const svgClass = isNewRound
                        ? 'w-12 h-12 dice-roll-animation' // Grande e animado.
                        : 'w-12 h-12';                   // Apenas grande.

                    // Substitui a classe original pela nova para aumentar o tamanho e animar.
                    dieDiv.innerHTML = diceSVGTags[d].replace('class="w-8 h-8"', `class="${svgClass}"`);
                    myDiceDisplay.appendChild(dieDiv);
                });
            }

            // 6. Habilita/desabilita e exibe/oculta ações
            const isMyTurn = currentUser.id === currentPlayer;
            const bottomActions = document.getElementById('bottom-actions');

            // Oculta completamente o painel de ações se não for a vez do jogador
            bottomActions.classList.toggle('hidden', !isMyTurn);

            if (isMyTurn) {
                // Se for a vez do jogador, reinicie a UI do lance para um valor válido.
                if (currentBid) {
                    // O próximo lance deve ser maior. Começa aumentando a face.
                    currentBidInput.quantity = currentBid.quantity;
                    currentBidInput.face = currentBid.face < 6 ? currentBid.face + 1 : 6;
                } else {
                    // Primeiro lance da rodada.
                    currentBidInput.quantity = 1;
                    currentBidInput.face = 1;
                }
                updateBidUI(); // Atualiza a exibição visual

                // Lógica de desabilitação específica para botões de desafio e exato
                challengeBtn.disabled = !currentBid;
                exactBtn.disabled = !currentBid;

                // Atualiza o feedback visual para os botões que podem ser desabilitados
                [challengeBtn, exactBtn].forEach(btn => {
                    if (btn.disabled) {
                        btn.classList.add('opacity-50', 'cursor-not-allowed');
                        btn.classList.remove('hover:scale-105', 'shadow-md');
                    } else {
                        btn.classList.remove('opacity-50', 'cursor-not-allowed');
                        btn.classList.add('hover:scale-105', 'shadow-md');
                    }
                });
            }

            // Sempre rola para o final do histórico após a renderização para mostrar a jogada mais recente ou os controles
            setTimeout(() => {
                historyContainer.scrollTop = historyContainer.scrollHeight;
            }, 100);
        }

        /**
         * Conta a ocorrência de uma face de dado específica entre todos os jogadores,
         * tratando os '1's como curingas.
         * @param {number} face - A face do dado a ser contada (de 1 a 6).
         * @param {object} players - O objeto de jogadores do estado do jogo.
         * @returns {number} A contagem total da face do dado.
         */
        function countDice(face, players) {
            let count = 0;
            for (const playerId in players) {
                players[playerId].dice.forEach(d => {
                    if (d === face) {
                        count++;
                    }
                });
            }
            return count;
        }

        async function handleGameStateUpdateForLeavingPlayer(leavingPlayerId, leavingName = 'Um jogador') {
            if (!gameState || !gameStarted || !gameState.players[leavingPlayerId]) {
                return; // Jogo não está ativo ou jogador não está no jogo.
            }

            try {
                const updatedGameState = JSON.parse(JSON.stringify(gameState));
                const originalTurnOrder = [...gameState.turnOrder];

                delete updatedGameState.players[leavingPlayerId];
                updatedGameState.turnOrder = updatedGameState.turnOrder.filter(id => id !== leavingPlayerId);

                updatedGameState.bidHistory.push({ type: 'status', message: `${leavingName} saiu do jogo.` });

                if (updatedGameState.turnOrder.length < 2) {
                    await Promise.race([
                        sb.from('rooms').update({ game_started: false }).eq('room_code', currentRoom.room_code),
                        timeout(5000)
                    ]).catch(e => console.warn("Falha ao atualizar sala após saída de jogador (timeout):", e));

                    await updateAndBroadcastGameState(null, false, { reason: 'not_enough_players', leavingPlayerName: leavingName });
                    return;
                }

                if (gameState.currentPlayer === leavingPlayerId) {
                    const leavingPlayerIndex = originalTurnOrder.indexOf(leavingPlayerId);
                    let nextPlayerId = null;
                    if (leavingPlayerIndex !== -1) {
                        for (let i = 1; i <= originalTurnOrder.length; i++) {
                            const nextIndex = (leavingPlayerIndex + i) % originalTurnOrder.length;
                            const potentialNextPlayerId = originalTurnOrder[nextIndex];
                            if (updatedGameState.players[potentialNextPlayerId] && updatedGameState.players[potentialNextPlayerId].diceCount > 0) {
                                nextPlayerId = potentialNextPlayerId;
                                break;
                            }
                        }
                    }
                    if (nextPlayerId) {
                        updatedGameState.currentPlayer = nextPlayerId;
                        const nextPlayerName = presences[nextPlayerId]?.[0]?.name || presences[nextPlayerId]?.[0]?.email || '...';
                        updatedGameState.currentTurnMessage = `É a vez de ${nextPlayerName}.`;
                    }
                }

                await updateAndBroadcastGameState(updatedGameState, true);
            } catch (error) {
                console.error(`Falha ao atualizar o estado do jogo após a saída do jogador: ${error.message}`);
                // Se a transmissão falhar, o estado pode ficar dessincronizado.
                // Uma notificação pode ser útil aqui para informar o anfitrião.
                showToast("Erro de rede ao atualizar o jogo. O estado pode estar inconsistente.");
            }
        }

        // --- 5. LÓGICA DE AUTENTICAÇÃO ---
        tabLogin.addEventListener('click', () => {
            loginForm.classList.remove('hidden');
            signupForm.classList.add('hidden');
            resetPasswordForm.classList.add('hidden');

            // Estilo da Aba Ativa
            tabLogin.classList.add('border-[#e5a938]', 'text-opacity-100');
            tabLogin.classList.remove('border-transparent', 'text-opacity-60');
            // Estilo da Aba Inativa
            tabSignup.classList.add('border-transparent', 'text-opacity-60');
            tabSignup.classList.remove('border-[#e5a938]', 'text-opacity-100');

            authMessage.textContent = '';
        });
        tabSignup.addEventListener('click', () => {
            signupForm.classList.remove('hidden');
            loginForm.classList.add('hidden');
            resetPasswordForm.classList.add('hidden');

            // Estilo da Aba Ativa
            tabSignup.classList.add('border-[#e5a938]', 'text-opacity-100');
            tabSignup.classList.remove('border-transparent', 'text-opacity-60');
            // Estilo da Aba Inativa
            tabLogin.classList.add('border-transparent', 'text-opacity-60');
            tabLogin.classList.remove('border-[#e5a938]', 'text-opacity-100');

            authMessage.textContent = '';
        });

        forgotPasswordLink.addEventListener('click', (e) => {
            e.preventDefault();
            loginForm.classList.add('hidden');
            signupForm.classList.add('hidden');
            resetPasswordForm.classList.remove('hidden');
            document.getElementById('auth-tabs-container').classList.add('hidden'); // Oculta as abas
            authMessage.textContent = '';
        });

        backToLoginLink.addEventListener('click', (e) => {
            e.preventDefault();
            resetPasswordForm.classList.add('hidden');
            loginForm.classList.remove('hidden');
            document.getElementById('auth-tabs-container').classList.remove('hidden'); // Mostra as abas
            tabLogin.click(); // Volta para a aba de login
        });

        signupForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            toggleLoading(true);
            try {
                const name = document.getElementById('signup-name').value;
                const email = document.getElementById('signup-email').value;
                const password = document.getElementById('signup-password').value;

                const { error } = await Promise.race([
                    sb.auth.signUp({
                        email: email,
                        password: password,
                        options: {
                            data: {
                                name: name
                            }
                        }
                    }),
                    timeout(15000, 'O cadastro demorou muito.')
                ]);

                if (error) {
                    if (error.message.includes('profiles_name_key')) {
                        showAuthMessage('O nome de usuário já existe.', true);
                    } else {
                        showAuthMessage(error.message, true);
                    }
                }
                else { showAuthMessage('Conta criada! Verifique seu email para confirmar.', false); signupForm.reset(); }
            } catch (err) {
                showAuthMessage("Ocorreu um erro inesperado.", true);
            } finally {
                toggleLoading(false);
            }
        });

        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            toggleLoading(true);
            try {
                const { error } = await Promise.race([
                    sb.auth.signInWithPassword({ email: document.getElementById('login-email').value, password: document.getElementById('login-password').value }),
                    timeout(15000, 'O login demorou muito.')
                ]);
                if (error) showAuthMessage(error.message, true);
                else { showAuthMessage(''); loginForm.reset(); }
            } catch (err) {
                showAuthMessage("Ocorreu um erro inesperado.", true);
            } finally {
                toggleLoading(false);
            }
        });

        resetPasswordForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            toggleLoading(true);
            const email = document.getElementById('reset-email').value;
            try {
                const { error } = await Promise.race([
                    sb.auth.resetPasswordForEmail(email, {
                        redirectTo: window.location.href, // Redireciona de volta para a mesma página
                    }),
                    timeout(15000, 'A solicitação de recuperação demorou muito.')
                ]);
                if (error) {
                    showAuthMessage(error.message, true);
                } else {
                    showAuthMessage('Link de recuperação enviado! Verifique seu email.', false);
                    resetPasswordForm.reset();
                }
            } catch (err) {
                showAuthMessage("Ocorreu um erro inesperado.", true);
            } finally {
                toggleLoading(false);
            }
        });

        logoutBtn.addEventListener('click', async () => {
            toggleLoading(true);
            try {
                await leaveRoomRealtime();
                await Promise.race([
                    sb.auth.signOut(),
                    timeout(5000)
                ]).catch(e => console.warn("SignOut timed out", e));
            } catch (err) {
                console.error("Erro ao fazer logout:", err);
                // Mesmo que haja um erro, o usuário provavelmente quer ser deslogado
                showView('auth-view'); // Força a volta para a tela de login
            } finally {
                toggleLoading(false);
            }
        });

        document.getElementById('proceed-btn').addEventListener('click', () => {
            showView('auth-view');
        });

        document.getElementById('initial-how-to-play-btn').addEventListener('click', () => {
            showView('how-to-play-view');
        });

        howToPlayBtn.addEventListener('click', () => {
            showView('how-to-play-view');
        });

        backToLobbyFromHowToPlayBtn.addEventListener('click', () => {
            showView(lastMainView || 'lobby-view');
        });

        // --- 6. LÓGICA DO MODAL DE CONFIGURAÇÕES (REFATORADO) ---

        // Função para mostrar uma view específica dentro do modal
        function showModalView(viewId) {
            settingsRoomView.classList.add('hidden');
            settingsAccountView.classList.add('hidden');
            document.getElementById(viewId).classList.remove('hidden');
        }

        // Função para preencher as informações da sala
        function populateRoomInfo() {
            modalRoomCode.textContent = currentRoom.room_code;
            modalParticipantsList.innerHTML = '';
            modalHostName.textContent = '';

            const participantIds = Object.keys(presences);
            const hostId = currentRoom?.creator_id;

            const hostPresence = presences[hostId];
            if (hostPresence && hostPresence.length > 0) {
                const hostName = hostPresence[0].name || hostPresence[0].email || 'Anfitrião anônimo';
                const isSelf = hostId === currentUser?.id;
                modalHostName.textContent = `${hostName}${isSelf ? ' (Você)' : ''}`;
            } else {
                modalHostName.textContent = 'Anfitrião não encontrado';
            }

            const otherPlayers = participantIds.filter(id => id !== hostId);
            if (otherPlayers.length > 0) {
                document.getElementById('modal-players-info').classList.remove('hidden');
                otherPlayers.forEach(id => {
                    const presencesForId = presences[id];
                    if (presencesForId.length > 0) {
                        const name = presencesForId[0].name || presencesForId[0].email || 'Usuário anônimo';
                        const isSelf = id === currentUser?.id;
                        const li = document.createElement('li');
                        li.textContent = `${name}${isSelf ? ' (Você)' : ''}`;
                        if (isSelf) li.classList.add('font-bold');
                        modalParticipantsList.appendChild(li);
                    }
                });
            } else {
                document.getElementById('modal-players-info').classList.add('hidden');
                modalParticipantsList.innerHTML = '<li class="text-gray-500">Nenhum outro jogador na sala.</li>';
            }
            const isHost = currentUser && currentRoom && currentUser.id === currentRoom.creator_id;
            modalHostControls.classList.toggle('hidden', !isHost || !gameStarted);

            const modalRoundInfo = document.getElementById('modal-round-info');
            if (gameStarted && gameState) {
                document.getElementById('modal-round-number').textContent = gameState.round;
                modalRoundInfo.classList.remove('hidden');
            } else {
                modalRoundInfo.classList.add('hidden');
            }
        }

        // Event Listeners
        musicToggleBtn.addEventListener('click', () => {
            SoundEngine.toggleMusic();
        });

        profileBtn.addEventListener('click', () => {
            profileMessage.textContent = ''; // Limpa mensagens antigas
            changeNameForm.reset();
            changePasswordForm.reset();
            showModalView('settings-account-view');
            settingsModal.classList.remove('hidden');
        });

        settingsBtn.addEventListener('click', () => {
            populateRoomInfo(); // Popula os dados antes de mostrar
            showModalView('settings-room-view');
            settingsModal.classList.remove('hidden');
        });

        closeModalBtn.addEventListener('click', () => {
            settingsModal.classList.add('hidden');
        });

        modalLogoutBtn.addEventListener('click', () => {
            settingsModal.classList.add('hidden');
            leaveRoomBtn.click();
        });

        changeNameForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            toggleLoading(true);
            profileMessage.textContent = '';
            const newName = document.getElementById('new-name').value;

            try {
                const { error } = await Promise.race([
                    sb.from('profiles').update({ name: newName }).eq('id', currentUser.id),
                    timeout(10000, 'A atualização do nome demorou muito.')
                ]);
                if (error) {
                    if (error.message.includes('profiles_name_key')) {
                        profileMessage.textContent = 'O nome de usuário já existe.';
                    } else {
                        profileMessage.textContent = error.message;
                    }
                    profileMessage.className = 'text-center text-sm mt-4 text-red-400';
                } else {
                    profileMessage.textContent = 'Nome atualizado com sucesso!';
                    profileMessage.className = 'text-center text-sm mt-4 text-green-400';
                    changeNameForm.reset();
                }
            } catch (err) {
                profileMessage.textContent = 'Ocorreu um erro inesperado.';
                profileMessage.className = 'text-center text-sm mt-4 text-red-400';
            } finally {
                toggleLoading(false);
            }
        });

        changePasswordForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            toggleLoading(true);
            profileMessage.textContent = '';
            const newPassword = document.getElementById('new-password').value;

            try {
                const { error } = await Promise.race([
                    sb.auth.updateUser({ password: newPassword }),
                    timeout(10000, 'A atualização da senha demorou muito.')
                ]);
                if (error) {
                    profileMessage.textContent = error.message;
                    profileMessage.className = 'text-center text-sm mt-4 text-red-400';
                } else {
                    profileMessage.textContent = 'Senha atualizada com sucesso!';
                    profileMessage.className = 'text-center text-sm mt-4 text-green-400';
                    changePasswordForm.reset();
                    // Fecha o modal após um curto período para o usuário ver a mensagem
                    setTimeout(() => {
                        profileModal.classList.add('hidden');
                    }, 2000);
                }
            } catch (err) {
                profileMessage.textContent = 'Ocorreu um erro inesperado.';
                profileMessage.className = 'text-center text-sm mt-4 text-red-400';
            } finally {
                toggleLoading(false);
            }
        });


        endGameBtn.addEventListener('click', async () => {
            if (!currentUser || !currentRoom || currentUser.id !== currentRoom.creator_id) return;

            settingsModal.classList.add('hidden');
            toggleLoading(true);

            try {
                // Compete a chamada de DB com um timeout.
                const { error } = await Promise.race([
                    sb.from('rooms').update({ game_started: false }).eq('room_code', currentRoom.room_code),
                    timeout(10000, 'A finalização do jogo demorou muito.')
                ]);

                if (error) {
                    throw new Error(`Erro de servidor ao finalizar o jogo: ${error.message}`);
                }

                // Transmite o estado finalizado. A UI será atualizada pelo ouvinte de broadcast.
                await updateAndBroadcastGameState(null, false);

            } catch (err) {
                console.error("Erro ao finalizar o jogo:", err.message);
                showToast(err.message || "Ocorreu um erro inesperado. Tente novamente.");
            } finally {
                // O carregamento é ocultado pelo próprio ouvinte de broadcast,
                // mas adicionamos um fallback aqui para garantir que ele seja sempre ocultado
                // em caso de falha na transmissão.
                toggleLoading(false);
            }
        });


        // --- 7. LÓGICA DAS SALAS (COM REALTIME) ---
        function handlePresenceSync(newState) {
            presences = newState; // Armazena o estado de presença mais recente

            // Lógica robusta para lidar com a desconexão do anfitrião.
            // O evento 'sync' é a fonte da verdade sobre quem está na sala.
            const participantIds = Object.keys(newState);
            const hostId = currentRoom?.creator_id;
            const isHostPresent = participantIds.includes(hostId);

            // Se o anfitrião não estiver mais presente e este cliente não for o anfitrião,
            // a sala deve ser fechada para este cliente.
            if (hostId && !isHostPresent && currentUser?.id !== hostId) {
                showToast("O anfitrião se desconectou. A sala foi fechada.");
                setTimeout(() => {
                    // Clica no botão de sair para garantir uma limpeza adequada do estado
                    leaveRoomBtn.click();
                }, 2500);
                return; // Impede a renderização adicional para evitar erros de estado
            }

            const listToUpdate = [participantsList]; // A lista do modal é atualizada ao abrir

            listToUpdate.forEach(list => {
                list.innerHTML = ''; // Limpa a lista antes de atualizar
                const participantIds = Object.keys(newState);

                if (participantIds.length > 0) {
                    participantIds.forEach(id => {
                        const presencesForId = newState[id];
                        if (presencesForId.length > 0) {
                            const name = presencesForId[0].name || presencesForId[0].email || 'Usuário anônimo';
                            const isHost = id === currentRoom?.creator_id;
                            const isSelf = id === currentUser?.id;

                            const li = document.createElement('li');
                            li.textContent = `${name}${isSelf ? ' (Você)' : ''}`;
                            if (isSelf) li.classList.add('font-bold');
                            list.appendChild(li);
                        }
                    });
                } else {
                    list.innerHTML = '<li class="text-gray-500">Ninguém aqui ainda...</li>';
                }
            });

            // Se o modal de configurações estiver aberto, atualiza as informações lá também
            if (!settingsModal.classList.contains('hidden')) {
                populateRoomInfo();
            }

            // Atualiza a UI da sala (ex: habilitar/desabilitar botão de iniciar)
            renderRoomUI();
            // NÃO chame renderGameUI() aqui. A atualização da UI do jogo deve ser
            // acionada APENAS pelo evento 'game_state_update' para garantir
            // que os clientes sempre renderizem o estado oficial mais recente do anfitrião,
            // evitando condições de corrida.
        }

        let handleGameStateUpdateBroadcast; // Declarado em um escopo mais alto

        async function joinRoomRealtime(roomCode) {
            if (!currentUser) return;
            await leaveRoomRealtime();
            // CORRIGIDO: Adicionado broadcast: { self: true } para que o anfitrião receba seus próprios eventos.
            // Isso é crucial para garantir que a UI do anfitrião seja atualizada pela mesma lógica que a dos outros jogadores.
            currentRoomChannel = sb.channel(`room:${roomCode}`, {
                config: {
                    presence: { key: currentUser.id },
                    broadcast: { self: true }
                }
            });

            // Ouvinte para ATUALIZAÇÕES GERAIS DO JOGO
            handleGameStateUpdateBroadcast = ({ payload }) => {
                try {
                    gameStarted = payload.gameStarted;
                    gameState = payload.gameState; // Pode ser nulo se o jogo terminou

                    // Atualiza a música de fundo baseada no estado do jogo
                    SoundEngine.updateBGMusic();

                    // Lógica adicional para tratar o motivo do fim do jogo
                    if (payload.reason === 'not_enough_players' || (payload.reason && payload.reason.reason === 'not_enough_players')) {
                        const leavingName = payload.reason?.leavingPlayerName || 'Um jogador';
                        showToast(`Fim de Jogo! O jogador ${leavingName} saiu. Sala fechada por jogadores insuficientes.`);
                        // Redireciona automaticamente para o lobby após exibir a mensagem
                        setTimeout(() => {
                            if (currentRoom) leaveRoomBtn.click();
                        }, 2500);
                    }

                    renderRoomUI(); // Sempre renderiza a UI da sala (que mostrará o lobby se gameStarted for falso)
                    // Renderiza a UI do jogo se houver um estado de jogo. Isso é crucial para
                    // exibir a tela de "fim de jogo" mesmo quando gameStarted é falso.
                    if (payload.gameState) {
                        // Efeitos sonoros para eventos específicos do jogo
                        if (payload.gameState.roundInfo.phase === 'reveal') {
                            playSound('lose-die-sound');
                        }
                        if (payload.reason === 'winner_declared') {
                            playSound('win-sound');
                        }
                        renderGameUI();
                    }

                    // --- LÓGICA DE REVELAÇÃO COM ATRASO (APENAS HOST) ---
                    const isHost = currentUser && currentRoom && currentUser.id === currentRoom.creator_id;
                    const currentPhase = gameState?.roundInfo?.phase;

                    if (isHost && (currentPhase === 'challenged' || currentPhase === 'exact_bid')) {
                        setTimeout(async () => {
                            const { players, currentBid, roundInfo } = gameState;
                            const actionTaker = roundInfo.actionTaker;
                            const bidder = roundInfo.bidder;

                            const actualQuantity = countDice(currentBid.face, players);
                            const allDice = Object.values(players).flatMap(p => p.dice.map(d => ({ playerId: p.id, face: d })));

                            let loser, roundMessage;
                            let losers = [];
                            const updatedPlayers = JSON.parse(JSON.stringify(players));

                            const actionTakerName = presences[actionTaker]?.[0]?.name || presences[actionTaker]?.[0]?.email;
                            const bidderName = presences[bidder]?.[0]?.name || presences[bidder]?.[0]?.email;

                            if (currentPhase === 'challenged') {
                                const bidWasCorrect = actualQuantity >= currentBid.quantity;
                                loser = bidWasCorrect ? actionTaker : bidder;
                                losers = [loser];
                                updatedPlayers[loser].diceCount = Math.max(0, updatedPlayers[loser].diceCount - 1);

                                const faceIcon = diceSVGTags[currentBid.face].replace('class="w-8 h-8"', 'class="w-6 h-6 inline-block"');

                                if (bidWasCorrect) {
                                    roundMessage = `O lance era <span class="text-green-400 font-bold">VERDADEIRO</span>! Havia ${actualQuantity} x ${faceIcon}.<br>${actionTakerName} perde um dado.`;
                                } else {
                                    roundMessage = `O lance era <span class="text-green-400 font-bold">FALSO</span>! Havia apenas ${actualQuantity} x ${faceIcon}.<br>${bidderName} perde um dado.`;
                                }
                            } else { // exact_bid
                                const bidWasExact = actualQuantity === currentBid.quantity;
                                const faceIcon = diceSVGTags[currentBid.face].replace('class="w-8 h-8"', 'class="w-6 h-6 inline-block"');

                                if (bidWasExact) {
                                    roundMessage = `${actionTakerName} <span class="text-green-400 font-bold">CRAVOU</span>! Havia exatamente ${actualQuantity} x ${faceIcon}.<br>Todos os outros perdem um dado.`;
                                    losers = Object.keys(updatedPlayers).filter(id => id !== actionTaker);
                                    for (const loserId of losers) {
                                        updatedPlayers[loserId].diceCount = Math.max(0, updatedPlayers[loserId].diceCount - 1);
                                    }
                                    loser = actionTaker; // Próximo a jogar
                                } else {
                                    losers = [actionTaker];
                                    updatedPlayers[actionTaker].diceCount = Math.max(0, updatedPlayers[actionTaker].diceCount - 1);
                                    roundMessage = `${actionTakerName} <span class="text-red-500 font-bold">ERROU</span>! Havia ${actualQuantity} x ${faceIcon}, não ${currentBid.quantity}.<br>Ele perde um dado.`;
                                    loser = actionTaker; // Próximo a jogar
                                }
                            }

                            // Check for a winner immediately after dice counts are updated
                            const remainingPlayerIds = Object.keys(updatedPlayers).filter(id => updatedPlayers[id].diceCount > 0);
                            let gameWinner = null;
                            if (remainingPlayerIds.length === 1) {
                                gameWinner = remainingPlayerIds[0];
                                const winnerName = presences[gameWinner]?.[0]?.name || 'O Vencedor';
                                roundMessage += `<br><br><strong class="text-amber-400 text-xl">${winnerName.toUpperCase()} É O VENCEDOR!</strong>`;
                            }


                            const revealGameState = {
                                ...gameState,
                                players: updatedPlayers,
                                roundInfo: {
                                    ...roundInfo,
                                    phase: 'reveal',
                                    loser: loser,
                                    losers: losers,
                                    actualQuantity: actualQuantity,
                                    message: roundMessage,
                                    allDice: allDice
                                }
                            };
                            // A lógica do vencedor foi movida para o manipulador de eventos 'nextRoundBtn'.
                            // Este bloco agora apenas transmite o resultado da rodada.
                            await updateAndBroadcastGameState(revealGameState, true, 'round_reveal');
                        }, 2500); // Atraso de 2.5 segundos para a animação
                    }

                    if (isHost && payload.gameState.roundInfo.phase === 'reveal') {
                        const remainingPlayersWithDice = gameState ? Object.values(gameState.players).filter(p => p.diceCount > 0).length : 0;
                        // Only set the timer if the game is not over, preventing the automatic winner announcement.
                        if (remainingPlayersWithDice >= 2) {
                            if (nextRoundTimeoutId) clearTimeout(nextRoundTimeoutId);
                            nextRoundTimeoutId = setTimeout(handleNextRound, 1000);
                        }
                    }
                } finally {
                    // Como a UI foi renderizada, oculta o overlay de carregamento.
                    // Isso é crucial para o anfitrião, que estava aguardando este evento.
                    toggleLoading(false);
                }
            };
            currentRoomChannel.on('broadcast', { event: 'game_state_update' }, handleGameStateUpdateBroadcast);

            // Ouvinte para o evento de fechamento da sala pelo anfitrião
            currentRoomChannel.on('broadcast', { event: 'host_left_and_closed_room' }, () => {
                // Não faça nada se este cliente for o anfitrião que está saindo
                if (currentUser.id === currentRoom.creator_id) return;

                showToast("O anfitrião se desconectou. A sala foi fechada.");
                // Aguarda um momento para o usuário ler a mensagem e então executa a ação de sair
                setTimeout(() => {
                    leaveRoomBtn.click(); // Simula o clique no botão de sair
                }, 2500);
            });

            currentRoomChannel.on('presence', { event: 'sync' }, () => handlePresenceSync(currentRoomChannel.presenceState()));

            // Ouvinte para detectar quando um jogador sai
            currentRoomChannel.on('presence', { event: 'leave' }, async ({ key, leftPresences }) => {
                const leavingPlayerId = key;
                const leavingName = leftPresences?.[0]?.name || 'Um jogador';

                // CORREÇÃO: Implementa um período de carência para a saída do anfitrião.
                // Isso evita uma condição de corrida onde o anfitrião parece sair imediatamente após criar a sala.
                if (leavingPlayerId === currentRoom.creator_id) {
                    const now = Date.now();
                    // Se o evento de saída ocorrer dentro de 1.5s da inscrição, ignore-o.
                    if (channelSubscribedAt && now - channelSubscribedAt < 1500) {
                        console.warn(`Ignorando o evento de saída do anfitrião devido ao período de carência.`);
                        return;
                    }
                }

                // Remoção de jogadores durante o jogo com um período de carência para desconexões temporárias.
                if (leavingPlayerId !== currentRoom.creator_id && gameStarted && currentUser.id === currentRoom.creator_id) {
                    console.log(`O jogador ${leavingName} (${leavingPlayerId}) saiu. Iniciando período de carência para remoção.`);

                    setTimeout(async () => {
                        // Verifica se o jogador continua desconectado após 8 segundos
                        if (!currentRoomChannel) return;
                        const stillGone = !currentRoomChannel.presenceState()[leavingPlayerId];

                        if (stillGone && gameStarted && currentRoom && currentUser && currentUser.id === currentRoom.creator_id) {
                            console.log(`O jogador ${leavingName} não retornou. Removendo do jogo.`);
                            await handleGameStateUpdateForLeavingPlayer(leavingPlayerId, leavingName);
                        } else {
                            console.log(`O jogador ${leavingName} retornou ou o estado do jogo mudou. Remoção cancelada.`);
                        }
                    }, 8000); // 8 segundos de carência
                }
            });

            currentRoomChannel.subscribe(async (status) => {
                if (status === 'SUBSCRIBED') {
                    playSound('enter-room-sound');
                    channelSubscribedAt = Date.now(); // Define o tempo de inscrição
                    try {
                        const { data: profile } = await Promise.race([
                            sb.from('profiles').select('name').eq('id', currentUser.id).single(),
                            timeout(5000)
                        ]);
                        await Promise.race([
                            currentRoomChannel.track({ name: profile?.name || currentUser.email, email: currentUser.email, joined_at: new Date().toISOString() }),
                            timeout(5000)
                        ]);
                    } catch (err) {
                        console.error("Erro ao rastrear presença no canal:", err);
                        // Tenta rastrear com dados mínimos se o perfil falhar
                        currentRoomChannel.track({ name: currentUser.email, email: currentUser.email, joined_at: new Date().toISOString() }).catch(() => {});
                    }
                }
            });
        }

        async function leaveRoomRealtime() {
            if (currentRoomChannel) {
                try {
                    // Tenta untrack e removeChannel com timeout para evitar travamentos
                    await Promise.race([
                        currentRoomChannel.untrack(),
                        timeout(3000)
                    ]).catch(e => console.warn("Untrack timed out or failed", e));

                    await Promise.race([
                        sb.removeChannel(currentRoomChannel),
                        timeout(3000)
                    ]).catch(e => console.warn("RemoveChannel timed out or failed", e));
                } catch (error) {
                    console.error('Erro ao sair do canal:', error);
                }
                currentRoomChannel = null;
                participantsList.innerHTML = '';
                channelSubscribedAt = null; // Redefine o tempo de inscrição
            }
        }

        createRoomBtn.addEventListener('click', async () => {
            toggleLoading(true);
            createRoomBtn.disabled = true;
            showLobbyMessage('', false);

            try {
                if (!currentUser) {
                    throw new Error('Usuário não está logado.');
                }
                const newCode = generateRoomCode();

                // Compete a chamada de DB com um timeout de 10 segundos
                const { data, error } = await Promise.race([
                    sb.from('rooms').insert({ room_code: newCode, creator_id: currentUser.id, game_started: false }).select().single(),
                    timeout(10000, 'A criação da sala demorou muito e foi cancelada.')
                ]);

                if (error) {
                    if (error.code === '23505') {
                        throw new Error('Erro ao criar sala, o código já existe. Tente novamente.');
                    }
                    throw error; // Lança outros erros de DB
                }

                if (data) {
                    currentRoom = data;
                    roomCodeDisplay.textContent = data.room_code;
                    showView('room-view');
                    await joinRoomRealtime(data.room_code);
                    await saveUserCurrentRoom(data.room_code);
                    renderRoomUI();
                } else {
                    // Caso em que nem data nem error são retornados (improvável, mas seguro)
                    throw new Error('Não foi possível obter os detalhes da sala após a criação.');
                }
            } catch (err) {
                console.error("Erro ao criar sala:", err.message);
                showLobbyMessage(err.message || "Ocorreu um erro inesperado. Tente novamente.", true);
            } finally {
                toggleLoading(false);
                createRoomBtn.disabled = false;
            }
        });

        joinRoomForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const submitButton = joinRoomForm.querySelector('button[type="submit"]');
            submitButton.disabled = true;
            toggleLoading(true);
            showLobbyMessage('', false);

            try {
                const code = roomCodeInput.value.toUpperCase().trim();
                if (!code) {
                    throw new Error('Por favor, insira um código.');
                }

                // Compete a chamada de DB com um timeout de 10 segundos
                const { data, error } = await Promise.race([
                    sb.from('rooms').select('room_code, creator_id, game_started').eq('room_code', code).maybeSingle(),
                    timeout(10000, 'A busca pela sala demorou muito e foi cancelada.')
                ]);

                if (error) {
                    throw error; // Lança erros de DB
                }

                if (data) {
                    if (data.game_started) {
                        throw new Error('O jogo já começou nesta sala.');
                    } else {
                        currentRoom = data;
                        roomCodeDisplay.textContent = data.room_code;
                        showView('room-view');
                        joinRoomForm.reset();
                        await joinRoomRealtime(data.room_code);
                        await saveUserCurrentRoom(data.room_code);
                        renderRoomUI();
                    }
                } else {
                    throw new Error('Sala não encontrada. Verifique o código.');
                }
            } catch (err) {
                console.error("Erro ao entrar na sala:", err.message);
                showLobbyMessage(err.message || "Ocorreu um erro inesperado. Tente novamente.", true);
            } finally {
                toggleLoading(false);
                submitButton.disabled = false;
            }
        });

        async function leaveRoom() {
            playSound('leave-room-sound');
            toggleLoading(true);
            leaveRoomBtn.disabled = true;

            const isHost = currentUser && currentRoom && currentUser.id === currentRoom.creator_id;

            try {
                if (isHost && currentRoomChannel) {
                    // Notifica outros jogadores que o anfitrião está saindo.
                    await Promise.race([
                        currentRoomChannel.send({ type: 'broadcast', event: 'host_left_and_closed_room' }),
                        timeout(5000, 'A notificação de fechamento da sala demorou muito.')
                    ]);

                    // Tenta deletar a sala do banco de dados.
                    const { error } = await Promise.race([
                        sb.from('rooms').delete().eq('room_code', currentRoom.room_code),
                        timeout(10000, 'A exclusão da sala demorou muito.')
                    ]);

                    if (error) {
                        // Mesmo que a exclusão falhe, o anfitrião ainda deve sair.
                        // O erro é registrado, mas não impede a limpeza local.
                        console.error("Erro ao deletar a sala:", error.message);
                        showToast(`Erro de rede ao fechar a sala: ${error.message}`);
                    }
                }

                // Executa as operações de limpeza de estado local (não relacionadas à rede diretamente).
                await leaveRoomRealtime();
                await clearUserCurrentRoom();

            } catch (err) {
                // Captura erros das operações de rede (send, delete).
                console.error("Erro de rede ao sair da sala:", err.message);
                showToast(err.message); // Mostra o erro de timeout/rede para o usuário.
            } finally {
                // Este bloco agora é executado de forma confiável, independentemente de timeouts.
                currentRoom = null;
                gameStarted = false;
                gameState = null;
                presences = {};

                document.getElementById('game-controls').innerHTML = '';
                settingsBtn.classList.add('hidden');

                setRoomViewMode(false); // GARANTE QUE A VIEW VOLTE AO ESTILO DE CARTÃO
                showView('lobby-view');
                showLobbyMessage('', false);

                toggleLoading(false);
                leaveRoomBtn.disabled = false;
            }
        }

        leaveRoomBtn.addEventListener('click', leaveRoom);


        // --- 8. LÓGICA DE AÇÕES DO JOGO ---

        function updateBidUI() {
            bidQuantityDisplay.textContent = currentBidInput.quantity;
            bidFaceDisplay.innerHTML = `<svg class="w-10 h-10"><use href="#dice-${currentBidInput.face}"></use></svg>`;
        }

        decreaseQuantityBtn.addEventListener('click', () => {
            const { currentBid } = gameState || {};
            const minQuantity = currentBid ? currentBid.quantity : 1;

            // Não pode diminuir abaixo do lance atual ou de 1
            if (currentBidInput.quantity > minQuantity) {
                currentBidInput.quantity--;
                 // Se a quantidade diminuir para a do lance atual, a face deve ser maior
                if (currentBidInput.quantity === currentBid?.quantity && currentBidInput.face <= currentBid?.face) {
                    currentBidInput.face = currentBid.face + 1;
                    if (currentBidInput.face > 6) {
                        currentBidInput.quantity++; // Se não for possível aumentar a face, reverte a diminuição da quantidade
                        currentBidInput.face = 1;
                    }
                }
                updateBidUI();
            }
        });

        increaseFaceBtn.addEventListener('click', () => {
            if (currentBidInput.face < 6) {
                currentBidInput.face++;
            } else {
                currentBidInput.face = 1; // Volta para 1
            }
            updateBidUI();
        });

        increaseQuantityBtn.addEventListener('click', () => {
            currentBidInput.quantity++;
            // Se a quantidade aumentar, a restrição da face do lance anterior é removida.
            // Opcional: redefinir a face para 1 para conveniência.
            const { currentBid } = gameState || {};
            if (currentBid && currentBidInput.quantity > currentBid.quantity) {
                currentBidInput.face = 1;
            }
            updateBidUI();
        });

        decreaseFaceBtn.addEventListener('click', () => {
            const { currentBid } = gameState || {};
            const minFace = (currentBid && currentBidInput.quantity === currentBid.quantity) ? currentBid.face + 1 : 1;

            if (currentBidInput.face > minFace) {
                currentBidInput.face--;
            } else {
                // Se não puder diminuir mais, volta para 6 (ou o máximo permitido)
                currentBidInput.face = 6;
            }
            updateBidUI();
        });


        bidBtn.addEventListener('click', async () => {
            if (!gameState || currentUser.id !== gameState.currentPlayer) return;

            const quantity = currentBidInput.quantity;
            const face = currentBidInput.face;

            // Validação do lance
            const { currentBid } = gameState;
            if (currentBid) {
                if (quantity < currentBid.quantity || (quantity === currentBid.quantity && face <= currentBid.face)) {
                    // Substitui alert() por showToast()
                    showToast("Seu lance deve ser maior que o lance atual.");
                    return;
                }
            }
             // Determina o próximo jogador usando a ordem de turno oficial
            const { turnOrder, players } = gameState;
            let nextPlayerId = null;
            const currentIndex = turnOrder.indexOf(currentUser.id);

            // Procura o próximo jogador com dados a partir do atual na ordem oficial de turnos
            for (let i = 1; i <= turnOrder.length; i++) {
                const nextIndex = (currentIndex + i) % turnOrder.length;
                const potentialId = turnOrder[nextIndex];
                if (players[potentialId] && players[potentialId].diceCount > 0) {
                    nextPlayerId = potentialId;
                    break;
                }
            }


            // Adiciona o lance ao histórico
            const newHistory = [...gameState.bidHistory];
            newHistory.push({ type: 'bid', playerId: currentUser.id, quantity, face });


                const nextPlayerPresence = presences[nextPlayerId]?.[0];
                const nextPlayerName = nextPlayerPresence?.name || nextPlayerPresence?.email || '...';
            // Atualiza o estado do jogo com o novo lance
            const updatedGameState = {
                ...gameState,
                currentBid: { quantity, face },
                lastBidder: currentUser.id,
                currentPlayer: nextPlayerId,
                turn: gameState.turn + 1,
                bidHistory: newHistory, // Atualiza o histórico
                    currentTurnMessage: `É a vez de ${nextPlayerName}.`
            };

            // Atualiza e transmite o estado
            await updateAndBroadcastGameState(updatedGameState, true);
        });

        exactBtn.addEventListener('click', async () => {
            if (!gameState || currentUser.id !== gameState.currentPlayer || !gameState.currentBid) return;

            // Apenas inicia a fase de "aposta exata", sem calcular o resultado.
            // O cálculo será feito pelo anfitrião após a animação.
            const updatedGameState = {
                ...gameState,
                roundInfo: {
                    ...gameState.roundInfo,
                    phase: 'exact_bid',
                    actionTaker: currentUser.id, // O jogador que clicou em "Cravar"
                    bidder: gameState.lastBidder,    // O jogador que fez o último lance
                }
            };

            await updateAndBroadcastGameState(updatedGameState, true);
        });

        challengeBtn.addEventListener('click', async () => {
            if (!gameState || currentUser.id !== gameState.currentPlayer || !gameState.currentBid) return;

            // Apenas inicia a fase de "desafio", sem calcular o resultado.
            // O cálculo será feito pelo anfitrião após a animação.
            const updatedGameState = {
                ...gameState,
                roundInfo: {
                    ...gameState.roundInfo,
                    phase: 'challenged',
                    actionTaker: currentUser.id, // O jogador que duvidou (desafiante)
                    bidder: gameState.lastBidder,    // O jogador que fez o último lance
                }
            };

            await updateAndBroadcastGameState(updatedGameState, true);
        });

        closeRoundResultBtn.addEventListener('click', () => {
            const roundResultOverlay = document.getElementById('round-result-overlay');
            roundResultOverlay.classList.add('hidden');
        });

        async function handleNextRound() {
            if (!gameState || !gameState.roundInfo.loser) return;

            // Apenas o anfitrião envia a atualização para evitar corridas.
            if (currentUser.id !== currentRoom.creator_id) {
                console.log("Apenas o anfitrião pode iniciar a próxima rodada.");
                return;
            }
            toggleLoading(true); // Mostra o carregamento

            try {
                // 1. Remove jogadores com 0 dados.
                const playersForNextRound = { ...gameState.players };
                let newTurnOrder = [...gameState.turnOrder];
                for (const playerId in playersForNextRound) {
                    if (playersForNextRound[playerId].diceCount <= 0) {
                        delete playersForNextRound[playerId];
                        newTurnOrder = newTurnOrder.filter(id => id !== playerId);
                    }
                }

                // 2. Verifica se há um vencedor.
                if (newTurnOrder.length < 2) {
                    const winnerId = newTurnOrder.length === 1 ? newTurnOrder[0] : null;
                    const finalGameState = {
                        ...gameState,
                        players: playersForNextRound, // Mantém os jogadores finais
                        gameWinner: winnerId,
                    };

                    // Atualiza o banco de dados para marcar o jogo como finalizado.
                    await Promise.race([
                        sb.from('rooms').update({ game_started: false }).eq('room_code', currentRoom.room_code),
                        timeout(5000)
                    ]).catch(e => console.warn("Falha ao atualizar banco de dados no fim do jogo:", e));

                    // Transmite o estado de vencedor final. `gameStarted` se torna `false`.
                    await updateAndBroadcastGameState(finalGameState, false, 'winner_declared');
                } else {
                    // 3. Se não houver vencedor, prepara a próxima rodada.
                    // CORREÇÃO: Determina o próximo jogador de forma segura.
                    let nextPlayerId = gameState.roundInfo.loser;
                    // Verifica se o perdedor ainda está no jogo (não saiu nem ficou sem dados).
                    if (!newTurnOrder.includes(nextPlayerId)) {
                        // Se o perdedor saiu, encontra o próximo jogador válido na ordem de turno original.
                        const originalLoserIndex = gameState.turnOrder.indexOf(gameState.roundInfo.loser);
                        if (originalLoserIndex !== -1) {
                            // Procura a partir da posição do perdedor na ordem de turno antiga.
                            for (let i = 0; i < gameState.turnOrder.length; i++) {
                                const potentialNextPlayerIndex = (originalLoserIndex + i) % gameState.turnOrder.length;
                                const potentialNextPlayerId = gameState.turnOrder[potentialNextPlayerIndex];
                                if (newTurnOrder.includes(potentialNextPlayerId)) {
                                    nextPlayerId = potentialNextPlayerId;
                                    break; // Encontrou um jogador válido.
                                }
                            }
                        }
                        // Se, por algum motivo, ninguém for encontrado (improvável), atribui o primeiro jogador ativo.
                        if (!newTurnOrder.includes(nextPlayerId)) {
                            nextPlayerId = newTurnOrder[0];
                        }
                    }

                    const nextRoundState = {
                        ...gameState,
                        players: playersForNextRound,
                        turnOrder: newTurnOrder,
                        currentBid: null,
                        lastBidder: null,
                        turn: 1,
                        round: gameState.round + 1,
                        currentPlayer: nextPlayerId, // Usa o ID do jogador determinado de forma segura
                        roundInfo: { phase: 'bidding', actionTaker: null, bidder: null, challenger: null, loser: null, losers: [], actualQuantity: 0, message: '' },
                        bidHistory: [],
                    };

                    const nextPlayerPresence = presences[nextRoundState.currentPlayer]?.[0];
                    const nextPlayerName = nextPlayerPresence?.name || nextPlayerPresence?.email || '...';
                    nextRoundState.currentTurnMessage = `É a vez de ${nextPlayerName}.`;
                    nextRoundState.bidHistory.push({ type: 'status', message: `Rodada ${nextRoundState.round} começou!`});

                    // Rola novos dados para os jogadores restantes.
                    for (const playerId in nextRoundState.players) {
                        const player = nextRoundState.players[playerId];
                        player.dice = Array.from({ length: player.diceCount }, () => Math.floor(Math.random() * 6) + 1);
                    }
                    await updateAndBroadcastGameState(nextRoundState, true);
                }
            } catch (error) {
                console.error("Erro ao processar a próxima rodada/vencedor:", error);
                showToast("Erro de rede. Tente novamente.");
            } finally {
                // O carregamento será ocultado pelo `game_state_update` listener,
                // mas adicionamos um fallback para garantir.
                setTimeout(() => toggleLoading(false), 500);
            }
        }

        backToLobbyBtn.addEventListener('click', async () => {
            leaveRoomBtn.click();
        });

        document.getElementById('final-back-to-lobby-btn').addEventListener('click', async () => {
            if (currentUser && currentRoom && currentUser.id === currentRoom.creator_id) {
                // Hide the overlay before resetting the game state
                document.getElementById('round-result-overlay').classList.add('hidden');

                // Garante que o banco de dados saiba que o jogo terminou (caso não tenha sido atualizado antes)
                await Promise.race([
                    sb.from('rooms').update({ game_started: false }).eq('room_code', currentRoom.room_code),
                    timeout(5000)
                ]).catch(e => console.warn("Falha ao atualizar banco de dados ao voltar para o lobby:", e));

                await updateAndBroadcastGameState(null, false);
            }
        });

        document.getElementById('final-leave-room-btn').addEventListener('click', leaveRoom);

        // --- 7. INICIALIZAÇÃO E AUTENTICAÇÃO ---
        async function handleUserLoggedIn(session) {
            if (!session) return; // Adiciona uma verificação para evitar erros se a sessão for nula
            currentUser = session.user;
            SoundEngine.updateBGMusic();

            // Atualização imediata do nome para melhorar a percepção de velocidade
            const initialName = currentUser.user_metadata?.name || currentUser.email;
            welcomeMessage.textContent = `Bem-vindo, ${initialName}`;

            try {
                const { data: profile, error } = await Promise.race([
                    sb.from('profiles').select('name, last_room').eq('id', currentUser.id).single(),
                    timeout(10000, 'A busca pelo perfil demorou muito.')
                ]);

                if (error) {
                    console.error('Erro ao buscar perfil:', error.message);
                    welcomeMessage.textContent = `Bem-vindo, ${currentUser.email}`;
                    showView('lobby-view'); // Falha para o lobby por segurança
                    return;
                }
                if (profile) {
                    welcomeMessage.textContent = `Bem-vindo, ${profile.name || currentUser.email}`;
                }

                if (profile && profile.last_room) {
                    const { data: roomData, error: roomError } = await Promise.race([
                        sb.from('rooms').select('room_code, creator_id').eq('room_code', profile.last_room).maybeSingle(),
                        timeout(10000, 'A busca pela última sala demorou muito.')
                    ]);

                    if (roomError) throw roomError;

                    if (roomData) {
                        currentRoom = roomData; // Armazena detalhes da sala

                        // Se for o anfitrião reentrando, garante que a sala esteja aberta para novos jogadores
                        // já que o estado do jogo não é persistido e ele voltará para o lobby.
                        if (currentUser.id === roomData.creator_id) {
                            await Promise.race([
                                sb.from('rooms').update({ game_started: false }).eq('room_code', roomData.room_code),
                                timeout(5000)
                            ]).catch(e => console.warn("Falha ao abrir sala para novos jogadores (timeout):", e));
                        }

                        roomCodeDisplay.textContent = roomData.room_code;
                        showView('room-view');
                        setRoomViewMode(true); // Entra no modo de tela cheia ao recarregar
                        joinRoomRealtime(roomData.room_code);
                        renderRoomUI(); // Renderiza a UI da sala
                    } else {
                        await clearUserCurrentRoom();
                        showView('lobby-view');
                    }
                } else {
                    showView('lobby-view');
                }
            } catch (err) {
                console.error("Erro em handleUserLoggedIn:", err);
                showView('lobby-view');
            }
        }

        // Implementação do formulário de atualização de senha
        updatePasswordForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            toggleLoading(true);
            const newPassword = document.getElementById('update-password').value;

            try {
                const { error } = await Promise.race([
                    sb.auth.updateUser({ password: newPassword }),
                    timeout(15000, 'A atualização da senha demorou muito.')
                ]);

                if (error) {
                    showAuthMessage(error.message, true);
                } else {
                    showAuthMessage('Senha atualizada com sucesso! Você já pode fazer o login.', false);
                    // Esconde o formulário de atualização e mostra o de login
                    updatePasswordForm.classList.add('hidden');
                    loginForm.classList.remove('hidden');
                    document.getElementById('auth-tabs-container').classList.remove('hidden'); // Mostra as abas
                    tabLogin.click(); // Garante que a aba de login esteja ativa
                }
            } catch (err) {
                showAuthMessage("Ocorreu um erro inesperado ao atualizar a senha.", true);
            } finally {
                toggleLoading(false);
            }
        });

        // Único listener para o estado de autenticação. Ele lida com o login inicial (INITIAL_SESSION) e todas as mudanças.
        sb.auth.onAuthStateChange(async (event, session) => {
            // Este manipulador é executado em segundo plano e não deve acionar um
            // indicador de carregamento visível, pois pode travar a UI em atualizações de sessão.
            // Apenas os manipuladores de eventos iniciados pelo usuário (login, logout, etc.) devem mostrar o spinner.
            try {
                // Evento especial para recuperação de senha
                if (event === 'PASSWORD_RECOVERY') {
                    showView('auth-view');
                    loginForm.classList.add('hidden');
                    signupForm.classList.add('hidden');
                    resetPasswordForm.classList.add('hidden');
                    updatePasswordForm.classList.remove('hidden');
                    document.getElementById('auth-tabs-container').classList.add('hidden'); // Oculta as abas
                    authMessage.textContent = '';
                    return; // Interrompe a execução para evitar processamento adicional
                }

                // Se existe uma sessão, o usuário está logado.
                if (session) {
                    // Se o formulário de atualização de senha estiver visível, oculta-o.
                    // Isso evita que ele permaneça na tela se o usuário atualizar a página após o login.
                    if (!updatePasswordForm.classList.contains('hidden')) {
                        updatePasswordForm.classList.add('hidden');
                        document.getElementById('auth-tabs-container').classList.remove('hidden');
                    }
                    await handleUserLoggedIn(session);
                }
                // Se não há sessão, o usuário está deslogado.
                else {
                    await leaveRoomRealtime();
                    currentUser = null;
                    showView('initial-view');
                }
            } catch (error) {
                console.error("Erro durante a mudança de estado de autenticação:", error);
                // Garante que o usuário veja a tela de login se algo der errado
                await leaveRoomRealtime();
                await Promise.race([
                    sb.auth.signOut(),
                    timeout(5000)
                ]).catch(e => console.error('O logout falhou no erro:', e));
                showView('initial-view');
            } finally {
                toggleLoading(false);
            }
        });

        window.addEventListener('beforeunload', () => { if (currentRoomChannel) leaveRoomRealtime(); });

        // Adiciona as outras funções de teste ao objeto existente
        Object.assign(window.testUtils, {
            sb: sb, // Expor o cliente Supabase para mocking
            showView: showView,
            renderRoomUI: renderRoomUI,
            renderGameUI: renderGameUI, // Expor a função de renderização do jogo
            handleUserLoggedIn: handleUserLoggedIn,
            setRoomViewMode: setRoomViewMode,
            triggerGameStateUpdate: handleGameStateUpdateBroadcast,
            joinRoomRealtime: joinRoomRealtime
        });
    </script>
</body>
</html>