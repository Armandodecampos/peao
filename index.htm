<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battle Blades 3D - Física Suavizada</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1a1a1a; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .stat-bar {
            width: 200px;
            height: 15px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            margin-bottom: 10px;
            overflow: hidden;
        }
        .fill {
            height: 100%;
            width: 100%;
            transition: width 0.3s;
        }
        #player-stamina { background: #3498db; }
        #enemy-stamina { background: #e74c3c; }
        
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(3, 60px);
            gap: 10px;
        }
        .btn {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            pointer-events: auto;
        }
        .btn:active { background: rgba(255,255,255,0.5); }
        #msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 2.5rem;
            display: none;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #fff;
            z-index: 10;
        }
        #restart {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1.2rem;
            cursor: pointer;
            pointer-events: auto;
            background: #fff;
            border: none;
            border-radius: 5px;
        }
    </style>
</head>
<body>

<div id="ui">
    <div>VOCÊ (Energia)</div>
    <div class="stat-bar"><div id="player-stamina" class="fill"></div></div>
    <div>OPONENTE (Energia)</div>
    <div class="stat-bar"><div id="enemy-stamina" class="fill"></div></div>
</div>

<div id="msg">
    <div id="status-text"></div>
    <button id="restart" onclick="resetGame()">Tentar Novamente</button>
</div>

<div id="controls">
    <div></div>
    <div class="btn" id="up">↑</div>
    <div></div>
    <div class="btn" id="left">←</div>
    <div class="btn" id="down">↓</div>
    <div class="btn" id="right">→</div>
</div>

<script>
    let scene, camera, renderer, arena, player, enemy;
    let keys = {};
    let gameOver = false;
    const ARENA_RADIUS = 10;
    const ARENA_DEPTH = 2.5; // Profundidade ligeiramente maior para segurar melhor
    
    const config = {
        player: {
            pos: new THREE.Vector3(-4, 0.5, 0),
            vel: new THREE.Vector3(0, 0, 0),
            stamina: 100,
            rotationSpeed: 0.5,
            color: 0x3498db,
            accel: 0.028
        },
        enemy: {
            pos: new THREE.Vector3(4, 0.5, 0),
            vel: new THREE.Vector3(0, 0, 0),
            stamina: 100,
            rotationSpeed: 0.5,
            color: 0xe74c3c,
            accel: 0.009 // IA um pouco mais lenta
        }
    };

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 16, 12);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const spotLight = new THREE.SpotLight(0xffffff, 1.2);
        spotLight.position.set(0, 25, 10);
        spotLight.castShadow = true;
        scene.add(spotLight);

        // Arena Côncava
        const arenaGeo = new THREE.CylinderGeometry(ARENA_RADIUS, ARENA_RADIUS * 0.3, 2, 64);
        const arenaMat = new THREE.MeshPhongMaterial({ 
            color: 0x222222, 
            shininess: 80,
            specular: 0x444444
        });
        arena = new THREE.Mesh(arenaGeo, arenaMat);
        arena.position.y = -1;
        arena.receiveShadow = true;
        scene.add(arena);

        const ringGeo = new THREE.TorusGeometry(ARENA_RADIUS, 0.12, 16, 100);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xff3300 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.rotation.x = Math.PI/2;
        ring.position.y = 0.05;
        scene.add(ring);

        player = createBlade(config.player.color);
        enemy = createBlade(config.enemy.color);
        scene.add(player);
        scene.add(enemy);

        resetPositions();

        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);
        setupButton('up', 'ArrowUp');
        setupButton('down', 'ArrowDown');
        setupButton('left', 'ArrowLeft');
        setupButton('right', 'ArrowRight');

        animate();
    }

    function setupButton(id, key) {
        const btn = document.getElementById(id);
        btn.addEventListener('mousedown', () => keys[key] = true);
        btn.addEventListener('mouseup', () => keys[key] = false);
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; });
        btn.addEventListener('touchend', () => keys[key] = false);
    }

    function createBlade(color) {
        const group = new THREE.Group();
        const bodyGeo = new THREE.ConeGeometry(0.8, 1, 12);
        const bodyMat = new THREE.MeshPhongMaterial({ color: color });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.rotation.x = Math.PI;
        body.castShadow = true;
        group.add(body);

        const ringGeo = new THREE.CylinderGeometry(1.3, 1.3, 0.3, 12);
        const ringMat = new THREE.MeshPhongMaterial({ color: 0xdddddd });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        ring.position.y = 0.3;
        group.add(ring);

        return group;
    }

    function resetPositions() {
        player.position.set(-5, 0.5, 0);
        enemy.position.set(5, 0.5, 0);
        config.player.vel.set(0,0,0);
        config.enemy.vel.set(0,0,0);
        config.player.stamina = 100;
        config.enemy.stamina = 100;
        gameOver = false;
        document.getElementById('msg').style.display = 'none';
    }

    function resetGame() { resetPositions(); }

    function checkCollision() {
        const dist = player.position.distanceTo(enemy.position);
        if (dist < 2.0) { // Distância de colisão ligeiramente reduzida
            const force = new THREE.Vector3().subVectors(player.position, enemy.position).normalize();
            
            // Impacto suavizado (de 0.45 para 0.22)
            const impact = (config.player.rotationSpeed + config.enemy.rotationSpeed) * 0.22;
            
            config.player.vel.addScaledVector(force, impact);
            config.enemy.vel.addScaledVector(force, -impact);

            config.player.stamina -= 3;
            config.enemy.stamina -= 4;
            
            // Pequeno salto
            player.position.y += 0.1;
            enemy.position.y += 0.1;
        }
    }

    function applyArenaPhysics(obj, c) {
        const distFromCenter = new THREE.Vector2(obj.position.x, obj.position.z).length();
        
        // Atração para o centro (Efeito Tigela)
        if (distFromCenter > 1.5) {
            // Força de atração aumentada para evitar saídas fáceis
            const pullStrength = Math.pow(distFromCenter / ARENA_RADIUS, 2) * 0.022;
            const centerDir = new THREE.Vector3(-obj.position.x, 0, -obj.position.z).normalize();
            c.vel.addScaledVector(centerDir, pullStrength);
            
            // Rampa visual
            const heightFactor = Math.pow(distFromCenter / ARENA_RADIUS, 2.5) * ARENA_DEPTH;
            obj.position.y = 0.5 + heightFactor;
        } else {
            if (obj.position.y > 0.5) obj.position.y -= 0.05;
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        if (gameOver) { renderer.render(scene, camera); return; }

        const acc = config.player.accel;
        if (keys['ArrowUp'] || keys['w']) config.player.vel.z -= acc;
        if (keys['ArrowDown'] || keys['s']) config.player.vel.z += acc;
        if (keys['ArrowLeft'] || keys['a']) config.player.vel.x -= acc;
        if (keys['ArrowRight'] || keys['d']) config.player.vel.x += acc;

        const dir = new THREE.Vector3().subVectors(player.position, enemy.position).normalize();
        config.enemy.vel.addScaledVector(dir, config.enemy.accel);

        [player, enemy].forEach((obj, i) => {
            const char = i === 0 ? 'player' : 'enemy';
            const c = config[char];
            
            obj.position.add(c.vel);
            c.vel.multiplyScalar(0.965); // Atrito ligeiramente aumentado para controlo

            applyArenaPhysics(obj, c);

            obj.rotation.y += c.rotationSpeed;
            c.rotationSpeed = (c.stamina / 100) * 0.6;
            c.stamina -= (char === 'player' ? 0.02 : 0.035);

            obj.rotation.z = -c.vel.x * 1.5;
            obj.rotation.x = c.vel.z * 1.5;
        });

        checkCollision();

        document.getElementById('player-stamina').style.width = Math.max(0, config.player.stamina) + '%';
        document.getElementById('enemy-stamina').style.width = Math.max(0, config.enemy.stamina) + '%';

        checkGameOver();
        renderer.render(scene, camera);
    }

    function checkGameOver() {
        const pDist = player.position.length();
        const eDist = enemy.position.length();
        let status = "";

        // Margem de erro maior antes de considerar que caiu (ARENA_RADIUS + 0.8)
        if (pDist > ARENA_RADIUS + 0.8) status = "VOCÊ CAIU!";
        else if (eDist > ARENA_RADIUS + 0.8) status = "OPONENTE EXPULSO!";
        else if (config.player.stamina <= 0) status = "ENERGIA ESGOTADA!";
        else if (config.enemy.stamina <= 0) status = "OPONENTE PAROU!";

        if (status !== "") {
            gameOver = true;
            const isWin = status.includes("OPONENTE");
            const st = document.getElementById('status-text');
            st.innerText = status;
            st.style.color = isWin ? "#2ecc71" : "#e74c3c";
            document.getElementById('msg').style.display = 'block';
        }
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
</body>
</html>
